<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解放C盘]]></title>
    <url>%2F2020%2F07%2F24%2F%E8%A7%A3%E6%94%BEC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[C盘一般都是作为系统盘来使用，相对空间会小一些。由于大多软件默认都是安装到这个磁盘，而且我们平时使用的应用依赖的配置或者缓存文件也同样存到这个磁盘中，所以它的空间很容易被占满。 相信大多数人早已意识到这个问题，所以在安装软件的时候都会把默认安装路径调整为其他磁盘，这样能在一定程度上缓解C盘的压力，但这只是其中的一个方面，这里分享一些供大家参考： 系统方面 定期清理一些不需要的安装包，自动下载的文件以及清空回收站的内容。这里推荐大家用Win10系统自带的存储感知功能，它可以在空间不足的时候自动释放还可以通过这个功能更新内容的保存位置。设置方法：win+s打开搜索栏-&gt;输入”设置”并打开对话框-&gt;点击”系统”-&gt;点击”存储”-&gt;开启存储感知，还可以按照需要点击”配置存储感知或立即运行”细化配置。 软件方面 我平时隔段时间会用360安全卫士清理磁盘，它可以清理常见应用产生的缓存、注册表中无效内容等。但我们经常使用的一些工具如果没有调整过配置那下载的依赖包或产生的缓存文件默认都存到了C盘，日积月累下会占用大量的系统盘空间，所以很有必要去调整相应的配置以减少C盘的存储压力。 首先创建一个应用数据公共存放文件夹：E:\ProgramData，接下来通过配置把应用下载的依赖或者缓存都指向这个路径下： 下面是我对一些自己常用工具的具体配置方式： MavenMaven是Java的包管理和安装工具，它默认的本地仓库路径为${user.home}/.m2/repository，在windows中会存到C盘下，本地仓库会占用很大一部分空间。 可以在用户配置文件中更改本地仓库路径，该文件位于C:\Users\{username}\.m2\settings.xml下，没有的话从Maven目录下复制一个，打开Idea的maven配置也可以发现默认会从这个路径下读取用户配置，所以可以在其中增加如下配置：1&lt;localRepository&gt;E:\ProgramData\maven\repository&lt;/localRepository&gt; 这样设置之后maven下载的依赖包就会保存到E盘指定目录中了。 NPMNPM是node的包管理工具，默认缓存和依赖包存储路径都在C盘下(可以使用npm config ls命令查看当前路径)，通过以下两条命令可以调整npm依赖包的缓存以及包存储路径：12npm config set cache &quot;E:\ProgramData\npm\npm-cache&quot;npm config set prefix &quot;E:\ProgramData\npm\npm_global&quot; 接下来再执行npm install -g xxx命令，下载的依赖包就会默认存到E盘指定路径下了。如果不想重新下载一遍已有的依赖，可以把已下载依赖复制到新路径下，不过不要忘记在环境变量中调整相应路径，否则全局依赖包提供的一些命令将无法正常使用。 PIPpip是Python包安装和管理工具，从3.4版本之后为Python的默认组件，不过这次需要调整源文件中的内容。 首先通过命令python -m site查看默认安装路径：这里的USER_BASE和USER_SITE其实就是默认的启用Python通过pip自动下载的脚本和依赖安装包的基础路径。 接下来使用命令python -m site -help查看安装目录配置文件路径：经过上面两步之后，我们找到了需要修改的文件site.py所在的位置，查看这个文件可以找到以下需要修改的两个常量：12345# for distutils.commands.install# These values are initialized by the getuserbase() and getusersitepackages()# functions, through the main() function when Python starts.USER_SITE = NoneUSER_BASE = None 从注释中我们能看出，这两个常量是用来设置工具包或者命令安装路径的，在Python启动的时候会进行初始化，可以修改如下(安装程序会自动帮我们创建文件夹)：12345# for distutils.commands.install# These values are initialized by the getuserbase() and getusersitepackages()# functions, through the main() function when Python starts.USER_SITE = 'E:\ProgramData\python\Python36\site-packages'USER_BASE = 'E:\ProgramData\python' 这样设置之后，我们执行类似pip install --user xxx命令就会安装依赖到指定的路径。需要注意的是这里的参数--user指定当前用户才可用，如果不加该参数为全局可用而且仍会默认安装到Python所在路径下，实际使用的时候出于安全考虑推荐大家增加这个参数。 Docker DesktopDocker Desktop依赖Win10的WSL可以方便的在windows中安装和使用docker，安装之后我尝试过设置镜像下载目录为其他磁盘，不过参考网上尝试了多次都没生效还经常搞得应用无法启动只能暂且放弃，有知道方法的朋友可以指点一下！ 参考资料： https://www.cnblogs.com/wuyicode/p/11404897.html https://blog.csdn.net/ZCShouCSDN/article/details/84990674 https://docs.docker.com/engine/reference/commandline/dockerd/#options-per-storage-driver]]></content>
  </entry>
  <entry>
    <title><![CDATA[你需掌握的CSS知识都在这了]]></title>
    <url>%2F2020%2F04%2F04%2Fall-of-css-konwledge%2F</url>
    <content type="text"><![CDATA[这篇文章基本涵盖了CSS主要的技术要点，内容比较丰富，可以作为参考看看自己还有哪些没掌握，有哪些需要进一步理解。 原文排版有点乱，有些内容也不是很全，本文对其进行了部分补充和调整。 CSS盒模型CSS盒模型，在不同浏览器的差异 CSS标准盒子模型css盒子模型又称为框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。如下图： 图中的最内层是content，然后依次是padding、border、margin。通常我们设置背景时就是内容、内边距、边框这三部分，如果border设置颜色的时候会显示boder颜色，当boder颜色是透明时会显示background-color的颜色。该元素的子元素的是从content开始的，而外边距是透明的，不会遮挡其他元素。 元素框的总宽度=width + padding_left + padding_right + border_left + border_right + margin_left + margin_right; 元素框的总高度=height + padding_top + padding_bottom + border_top + border_bottom + margin_top + margin_bottom; IE盒子模型IE盒子模型如下图： 图中的最内层是content，然后依次是padding、border。通常我们设置背景时就是内容、内边距、边框这三部分。而外边距是透明的，不会遮挡其他元素。 元素框的总宽度=width（padding_left + padding_right + border_left + border_right)； 元素框的总高度=height（padding_top + padding_bottom + border_top + border_bottom）; 两个模型宽度和高度的计算（是不一样的） w3c中的盒子模型的宽:包括margin + border + padding + width; width:margin×2 + border×2 + padding×2 + width; height:margin×2 + border×2 + padding×2 + height; IE中的盒子模型的width:包括border + padding + width; 上面的两个宽度相加的属性是一样的。因此我们应该选择标准盒子模型，在网页的顶部加上DOCTYPE声明。 CSS选择器CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则 CSS选择器种类 通用选择器：* id选择器：#header{} class选择器：.header{} 元素选择器：div{} 子选择器：ul &gt; li{} 后代选择器：div p{} 伪类选择器：:hover、::selection、.action、:first-child、:last-child、:first-of-type、:last-of-type、:nth-of-type(n)、:nth-of-last-type(n)等,例如a:hover{} 伪元素选择器: :after、:before等,例如：li:after 属性选择器: input[type=”text”] 组合选择器：E,F/E F（后代选择器）/E&gt;F（子元素选择器）/E+F（直接相邻元素选择器—-匹配之后的相邻同级元素）/E~F（普通相邻元素选择器—-匹配之后的同级元素） 层次选择器：p~ul（选择前面有p元素的每个ul元素） CSS选择器优先级选择器优先级由高到低分别为：!important &gt; 作为style属性写在元素标签上的内联样式 &gt; id选择器 &gt; 类选择器 &gt; 伪类选择器 &gt; 属性选择器 &gt; 标签选择器 &gt; 通配符选择器（* 应少用）&gt; 浏览器自定义； 当比较多个相同级别的CSS选择器优先级时，它们定义的位置将决定一切。下面从位置上将CSS优先级由高到低分为六级： 位于&lt;head/&gt;标签里的&lt;style/&gt;中所定义的CSS拥有最高级的优先权。 第二级的优先属性由位于&lt;style/&gt;标签中的 @import引入样式表所定义。 第三级的优先属性由&lt;link/&gt;标签所引入的样式表定义。 第四级的优先属性由&lt;link/&gt;标签所引入的样式表内的 @import导入样式表定义。 第五级优先的样式有用户设定。 最低级的优先权由浏览器默认。 使用场景 class使用场景：需要某些特定样式的标签则放在同一个class中，需要此样式的标签可再添加此类。（class不可被javascript中的GetElementByID函数所调用） id使用场景： 根据提供的唯一id号快速获取标签对象，如：document.getElementById(id) ； 用于充当label标签for属性的值：示例：&lt;label for=’userid’&gt;用户名：&lt;/label&gt;，表示单击此label标签时，id为userid的标签获得焦点 CSS哪些属性可以继承css继承特性主要是指文本方面的继承(比如字体、颜色、字体大小等)，盒模型相关的属性基本没有继承特性。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、top、bottom、left、right、z-index、float、clear、 table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi 所有元素可继承的：visibility和cursor 终极块级元素可继承的：text-indent和text-align 内联元素可继承的：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction 列表元素可继承的：list-style、list-style-type、list-style-position、list-style-image 常用@规则及使用示例常用@规则有：@charset、@import、@namespace、@document、@font-face、@keyframes、@media、@page、@supports12345678910/*定义字符集*/@charset "utf-8"/*导入css文件*/@import "base.css"/*自定义字体*/@font-face &#123;&#125;/*声明CSS3 animation动画关键帧*/@keyframes fadeIn &#123;&#125;/*媒体查询*/@media&#123;&#125; CSS伪类和伪元素CSS伪类和伪元素有哪些，它们的区别和实际应用 举例和区别常见伪类：:hover、:active、first-child、:visited 常见伪元素：:first-line、:first-letter、:after、:before 伪类和伪元素的根本区别在于它们是否创造了新的元素(抽象)。从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是伪元素；如果只需要在既有元素上添加类别的，就是伪类。 伪元素在一个选择器里只能出现一次，并且只能出现在末尾; 伪类则是像真正的类一样发挥着类的作用，没有数量上的限制，只要不是相互排斥的伪类，也可以同时使用在相同的元素上。 实际使用 伪类用一个冒号表示：:first-child 伪元素则使用两个冒号表示：::first-line CSS定位CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理 定位方式1）static定位(普通流定位)——默认定位 2）float定位(浮动定位) 例：float:left; 有两个取值：left(左浮动)和right(右浮动)。浮动元素会在没有浮动元素的上方，效果上看是遮挡住了没有浮动的元素，有float样式规则的元素是脱离文档流的，它的父元素的高度并不能有它撑开。 3）relative定位(相对定位) position:relative; 相对本元素的左上角进行定位，top,left,bottom,right都可以有值。虽然经过定位后，位置可能会移动，但是本元素并没有脱离文档流，还占有原来的页面空间。可以设置z-index。使本元素相对于文档流中的元素，或者脱离文档流但是z-index的值比本元素的值要小的元素更加靠近用户的视线。 相对定位最大的作用是为了实现某个元素相对于本元素的左上角绝对定位，本元素需要设置position为relative。 4）absolute定位(绝对定位) position:absolute; 相对于祖代中有relative(相对定位)并且离本元素层级关系上是最近的元素的左上角进行定位，如果在祖代元素中没有有relative定位的，就默认相对于body进行定位。 绝对定位是脱离文档流的，与浮动定位是一样的效果，会压在非定位元素的上方。可以设置z-index属性。 雪碧图实现原理CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。 居中方案写出尽可能多的水平垂直居中的方案并对比它们的优缺点 行内元素水平居中首先看它的父元素是不是块级元素，如果是，则直接给父元素设置text-align: center;如果不是，则先将其父元素设置为块级元素，再给父元素设置text-align: center; 块级元素水平居中(定宽度)1）需要谁居中，给其设置margin: 0 auto;（作用：使盒子自己居中） 2）首先设置父元素为相对定位，再设置子元素为绝对定位： 设置子元素的left:50%，即让子元素的左上角水平居中； 设置子元素的margin-left: 元素宽度的一半px; 设置子元素的transform: translateX(-50%); 块级元素水平居中(不定宽度)1) 默认子元素的宽度和父元素一样，这时需要设置子元素为display: inline-block;或display: inline;即将其转换成行内块级/行内元素，给父元素设置text-align: center; 2) 首先设置父元素为相对定位，再设置子元素为绝对定位： 设置子元素的left:50%，即让子元素的左上角水平居中； 利用css3新增属性transform: translateX(-50%); 块级元素水平居中（宽度定不定都可以）使用flexbox布局，只需要给待处理的块状元素的父元素添加属性display: flex; justify-content: center; 单行的行内元素垂直居中只需要设置单行行内元素的”行高等于盒子的高”即可； 多行的行内元素垂直居中使用给父元素设置display:table-cell;和vertical-align: middle;即可。 块级元素垂直居中方法一：使用定位 首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的top: 50%，即让子元素的左上角垂直居中； 定高度：设置绝对子元素的margin-top: -元素高度的一半px; 或者设置transform: translateY(-50%); 不定高度：利用css3新增属性transform: translateY(-50%); 方法二：使用flexbox布局实现（高度定不定都可以） 使用flexbox布局，只需要给待处理的块状元素的父元素添加属性display: flex; align-items: center; 水平垂直居中-已知高度和宽度的元素方法一：设置父元素为相对定位，给子元素设置绝对定位，top: 0; right: 0; bottom: 0; left: 0; margin: auto; 方法二：设置父元素为相对定位，给子元素设置绝对定位，left: 50%; top: 50%; margin-left: 元素宽度的一半px; margin-top: 元素高度的一半px; 水平垂直居中-未知高度和宽度的元素方法一：使用定位属性 设置父元素为相对定位，给子元素设置绝对定位：left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%); 方案二：使用flex布局实现 设置父元素为flex定位：justify-content: center; align-items: center; BFCBFC的布局规则，实现原理，可以解决的问题 BFC直译为块级格式化上下文，它是一个独立的渲染区域，只有Block-level box参与，它规定了内部的Block-level Box如何布局，并且与外部毫不相干。注意：可以把BFC理解为一个大的盒子，其内部是由Block-level box组成的。 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 BFC的作用及原理 自适应两栏布局 清除内部浮动 防止垂直margin重叠 BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。 CSS函数 根据w3cplus中可以划分为以下几类： 属性函数：attr()； 背景图片函数：linear-gradient()、radial-gradient()、conic-gradient()、repeating-linear-gradient()、repeating-radial-gradient()、repeating-conic-gradient()、image-set()、image()、url()、element()； 颜色函数：rgb()、rgba()、hsl()、hsla()、hwb()、color-mod()； 图形函数：circle()、ellipse()、inset()、polygon()、path() 滤镜函数：blur()、brightness()、contrast()、drop-shadow()、grayscale()、hue-rotate()、invert()、opacity()、saturate()、sepia()； 转换函数：matrix()、matrix3d()、perspective()、rotate()、rotate3d()、rotateX()、rotateY()、rotateZ()、scale()、scale3d()、scaleX()、scaleY()、scaleZ()、skew()、skewX()、skewY()、translate()、translateX()、translateY()、translateZ()、translate3d()； 数学函数：calc()、min()、max()、mixmax()、repeat()； 缓动函数：cubic-bezier()、steps()； 其他函数：counter()、counters()、toggle()、var()、 symbols()。 PostCSS、Sass与LessPostCSS、Sass、Less的异同，以及使用配置，至少掌握一种 比较 编译环境不一样，Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中； 变量符号不一样，Less是@，而Scss是$； 输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded； 处理条件语句，Sass支持条件语句，可以使用if{}else{},for{}循环等等。 LESS的条件语句使用有些另类，他不是我们常见的关键词if和else if之类，而其实现方式是利用关键词”when”； 引用外部文件，文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件，ess引用外部文件和css中的@import没什么差异； 工具库的不同，Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass在Sass的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。 PostCSS介绍PostCSS 的主要功能只有两个：第一个就是前面提到的把CSS解析成JavaScript可以操作的 AST，第二个就是调用插件来处理 AST 并得到结果。因此，不能简单的把 PostCSS 归类成 CSS 预处理或后处理工具。PostCSS 所能执行的任务非常多，同时涵盖了传统意义上的预处理和后处理。 使用PostCSS 一般不单独使用，而是与已有的构建工具进行集成。PostCSS 与主流的构建工具，如 Webpack、Grunt 和 Gulp 都可以进行集成。完成集成之后，选择满足功能需求的 PostCSS 插件并进行配置。现在经常用到的是基于PostCSS的Autoprefixer插件，使用方式可以在官网的插件库进行查询。下面是官网地址： PostCSS官网地址 CSS模块化方案 css的模块化方案可能和js一样有很多，下面简单介绍几种主要的模块方案。 OOCSS面向对象的CSS，面对对象的规则，主要的原则是两种：分离结构和外观，分离容器和内容。 名词解释分离结构和外观：增加可重复的设计单元，同时去推进产品和ui对这方面的思考，比如下面的css使用时对象模式的命名和模块化规则。 分离容器和内容：指的是样式的使用不以元素位置唯一匹配，在任何位置你都可以使用这个样式，如果你不适用这个样式，会保持默认的样式。 案例1234567// dom结构&lt;div id="toogle" class="toogle simple"&gt; &lt;div class="toogle-control open"&gt; &lt;div class="toogle-tittle"&gt;标题&lt;/div&gt; &lt;/div&gt; &lt;div class="toogle-details "&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920/* 模块的标记 */toogle.toggle&#123;&#125;/* 皮肤样式的写法，如果基本结构是一样的，你可以用complex的一个辅助样式 */.toggle .simple&#123;&#125;/* 是否做嵌套写法 相信很多预处理器的部分会支持嵌套 然后很多人会像下面这样写 */.toogle&#123; .toogle-control&#123; &#125; .toogle-details&#123; &#125;&#125;/* 其实你会这样组织么?不是很建议，这样会降低查询效率，如果能确认唯一性的时候其实直接写即可 */.toogle&#123;&#125;.toogle-control&#123;&#125;.toogle-details&#123;&#125; SMACSSSMACSS通过一个灵活的思维过程来检查你的设计过程和方式是否符合你的架构，更像一种规范。设计的主要规范有三点： Categorizing CSS Rules（为css分类） Naming Rules（命名规范） Minimizing the Depth of Applicability（最小化适配深度） SMA和OOCSS有很多类似之处，但区分的地方有很多，主要是对样式的分类。分别是：基础、布局、模块、状态、主题 基础可以适用于任何位置，我也称全局样式 布局主要是用来实现不同的特色布局，提高布局的复用率， 模块设计中的模块化，可重复使用的一个单元，一般是dom+css的耦合绑定。 状态描述在特定状态下的布局或者模块的特殊化表现，这里我觉得要推荐下《css禅意花园》，在dom结构不变的情况下，可以通过css的皮肤化实现样式的改版。 主题与状态相比更加定制的是，我们会针对有些特殊的模块，进行主题的设置，包括一系列的颜色、尺寸、交互等进行重度设计，参数化设计。 案例1234567// dom结构&lt;div class="toogle toogle-simple"&gt; &lt;div class="toogle-control is-active"&gt; &lt;div class="toogle-tittle"&gt;标题&lt;/div&gt; &lt;/div&gt; &lt;div class="toogle-details "&gt;&lt;/div&gt;&lt;/div&gt; 与oocss相比，其实大部分设计思路是一样的，以一个类作为css的作用域（作用域就是两个限制，1、不符合场景时限制禁止使用 ；2、符合场景时要正确的使用），另外的区别就是针对皮肤和状态的不同书写规则。 BEMBEM分别代表着:Block(块)、Element(元素)、Modifier(修饰符)，是一种组件化的 CSS 命名方法和规范，由俄罗斯 Yandex 团队所提出。它不涉及具体的css结构，只是建议你如何命名css。 案例1234567// dom结构&lt;div class="toogle toogle--simple"&gt; &lt;div class="toogle_control toogle_control--active"&gt; &lt;div class="toogle_tittle"&gt;标题&lt;/div&gt; &lt;/div&gt; &lt;div class="toogle_details "&gt;&lt;/div&gt;&lt;/div&gt; 解释块级：所属组件的名称 元素：元素在组件里的名称 修饰符：任何与元素修饰相关的类 style-components彻底抛弃 CSS，用 JavaScript 写 CSS 规则,点击style-components进入github的主页。 CSS Modules使用JS编译原生的CSS文件，使其具备模块化的能力，点击CSS Modules进入github主页。 这些模块化方案都是各有优缺点，如命名约定：命名复杂、缺乏扩展、 CSS Modules当然也有一些缺点(你得先学会它再去谈优劣)。在众多解决方案中，没有绝对的优劣。还是要结合自己的场景来决定。 CSS如何配置按需加载 使用require.js按需加载CSS 1234567891011121314151617181920//模块test.jsdefine(['css!../css/test.css'], function() &#123; //先加载依赖样式 var test = &#123;&#125;; return test;&#125;);//配置require.config(&#123; map: &#123; //map告诉RequireJS在任何模块之前，都先载入这个模块 '*': &#123; css: 'lib/css' &#125; &#125;, paths: &#123; test: 'lib/test', &#125;&#125;);//调用require(['test']) webpack配置CSS的按需加载这里以ant desgin css 为例： 1234567891011121314151617181920212223242526&#123; test: /\.(js|mjs|jsx|ts|tsx)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; customize: require.resolve( 'babel-preset-react-app/webpack-overrides' ), plugins: [ ["import",&#123;libraryName: "antd", style: 'css'&#125;], //只需加一行，手动划重点antd按需加载 [ require.resolve('babel-plugin-named-asset-import'), &#123; loaderMap: &#123; svg: &#123; ReactComponent: '@svgr/webpack?-svgo,+ref![path]', &#125;, &#125;, &#125;, ], ], cacheDirectory: true, cacheCompression: isEnvProduction, compact: isEnvProduction, &#125;,&#125; 如何防止CSS阻塞渲染 默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。请务必精简您的 CSS，并利用媒体类型和查询来解除对渲染的阻塞。 我们可以通过 CSS”媒体类型”和”媒体查询”来解决这类用例： 123&lt;link href="style.css" rel="stylesheet"&gt;&lt;link href="print.css" rel="stylesheet" media="print"&gt;&lt;link href="other.css" rel="stylesheet" media="(min-width: 40em)"&gt; 媒体查询由媒体类型以及零个或多个检查特定媒体特征状况的表达式组成。 例如，上面的第一个样式表声明未提供任何媒体类型或查询，因此它适用于所有情况，也就是说，它始终会阻塞渲染。第二个样式表则不然，它只在打印内容时适用——或许您想重新安排布局、更改字体等等，因此在网页首次加载时，该样式表不需要阻塞渲染。最后，最后一个样式表声明提供由浏览器执行的”媒体查询”：符合条件时，浏览器将阻塞渲染，直至样式表下载并处理完毕。 CSS(3)实现常见动画熟练使用CSS(3)实现常见动画，如渐变、移动、旋转、缩放等等 我把一些常用的CSS动画效果代码上传到github了，有需要的同学可以点击下载，CSS常用动画； 另外还有一些CSS动画库，比如：animate.css、magic.css、Hover.css。 CSS浏览器兼容性写法 浏览器CSS样式初始化由于每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化，相信很多朋友都写过这样的代码，在所有CSS开始前，先把marin和padding都设为0，以防不同浏览器的显示效果不一样。 1234* &#123; margin: 0; padding: 0;&#125; 关于浏览器CSS样式初始化，经验不丰富的话，可能也不知道该初始化什么，这里给大家推荐一个库，Normalize.css，github star数量接近3.4万，选取展示其中几个样式设置，如下： 12345678910111213141516html &#123; line-height: 1.15; /* Correct the line height in all browsers */ -webkit-text-size-adjust: 100%; /* Prevent adjustments of font size after orientation changes in iOS. */&#125;body &#123; margin: 0;&#125;a &#123; background-color: transparent; /* Remove the gray background on active links in IE 10. */&#125;img &#123; border-style: none; /* Remove the border on images inside links in IE 10. */&#125; 通过CSS样式初始化，相信能解决不少常规的兼容性问题，接下来再看看浏览器的私有属性。 浏览器私有属性我们经常会在某个CSS的属性前添加一些前缀，比如-webkit-，-moz- ，-ms-，这些就是浏览器的私有属性。 为什么会出现私有属性呢？这是因为制定HTML和CSS标准的组织W3C动作是很慢的。 通常，有W3C组织成员提出一个新属性，比如说圆角border-radius，大家都觉得好，但W3C制定标准，要走很复杂的程序，审查等。而浏览器商市场推广时间紧，如果一个属性已经够成熟了，就会在浏览器中加入支持。 但是为避免日后W3C公布标准时有所变更，会加入一个私有前缀，比如-webkit-border-radius，通过这种方式来提前支持新属性。等到日后W3C公布了标准，border-radius的标准写法确立之后，再让新版的浏览器支持border-radius这种写法。常用的前缀有： -moz代表firefox浏览器私有属性 -ms代表IE浏览器私有属性 -webkit代表chrome、safari私有属性 -o代表opera私有属性 对于私有属性的顺序要注意，把标准写法放到最后，兼容性写法放到前面 12345-webkit-transform:rotate(-3deg); /*为Chrome/Safari*/-moz-transform:rotate(-3deg); /*为Firefox*/-ms-transform:rotate(-3deg); /*为IE*/-o-transform:rotate(-3deg); /*为Opera*/transform:rotate(-3deg); 每个CSS属性写这么一堆兼容性代码，无疑是对生命最大的浪费，后面我们会讲一下通过自动化插件来处理这块。 CSS hack有时我们需要针对不同的浏览器或不同版本写特定的CSS样式，这种针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack! CSS hack的写法大致归纳为3种：条件hack、属性级hack、选择符级hack。 各游览器常用兼容标记一览表: 标记 IE6 IE7 IE8 FF Opera Sarari [*+&gt;&lt;] √ √ X X X X _ √ X X X X X \9 √ √ √ X X X \0 X X √ X √ X @media screen and (-webkit-min-device-pixel-ratio:0){.bb {}} X X X X X √ .bb , x:-moz-any-link, x:default X √ X √(ff3.5及以下) X X @-moz-document url-prefix(){.bb{}} X X X √ X X @media all and (min-width: 0px){.bb {}} X X X √ √ √ * +html .bb {} X √ X X X X 游览器内核 Trident Trident Trident Gecko Presto WebKit 注：以上.bb 可更换为其它样式名 自动化插件Autoprefixer是一款自动管理浏览器前缀的插件，它可以解析CSS文件并且添加浏览器前缀到CSS内容里，使用Can I Use（caniuse网站）的数据来决定哪些前缀是需要的。 把Autoprefixer添加到资源构建工具（例如Grunt）后，可以完全忘记有关CSS前缀的东西，只需按照最新的W3C规范来正常书写CSS即可。如果项目需要支持旧版浏览器，可修改browsers参数设置 。 12345678910111213//我们编写的代码div &#123; transform: rotate(30deg);&#125;// 自动补全的代码，具体补全哪些由要兼容的浏览器版本决定，可以自行设置div &#123; -ms-transform: rotate(30deg); -webkit-transform: rotate(30deg); -o-transform: rotate(30deg); -moz-transform: rotate(30deg); transform: rotate(30deg);&#125; 目前webpack、gulp、grunt都有相应的插件，如果还没有使用，那就赶紧应用到我们的项目中吧，别再让CSS兼容性浪费你的时间！ 响应式布局方案 比较常用的布局方式有float,position,display,table,flex,grid等。 全屏布局相关方案的兼容性、性能和自适应一览表： 方案 兼容性 性能 是否自适应 Position 好 好 部分自适应 Flex 较差 差 可自适应 Grid 差 较好 可自适应 实际项目使用中一般是根据具体场景去选择相应的布局方式。 CSS知识图谱 本文整理自https://juejin.im/post/5d8336d2f265da03df5f4a06。]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探Drone]]></title>
    <url>%2F2020%2F03%2F30%2Ffirst-exploration-of-drone%2F</url>
    <content type="text"><![CDATA[Drone是一个现代化的持续集成和持续交付平台，使繁忙的团队能够自动化他们的构建、测试和发布工作流。 上面是官方对Drone的定义，和我们在工作过程中用的Jenkins一样，这是一款开源的CI/CD软件。不过Drone是基于Docker的，这一点也许是它的一大优势，它的所有编译和测试流程都在Docker容器中执行，与Jenkins相比它安装方便配置简单，此外也很容易集成到我们应用中。 在大概了解一番后，我想着试用下看看，于是在网上搜了下，不过发现资料不是很多，而且比较坑的是搜到的文章中部署使用方法和官网描述的不太一致，这一点在具体过程中再细说。没有办法，只能完全参考官网的教程了，以下是具体的过程： 环境准备 我用的是阿里云的ECS，装有CentOS7系统，并且已经安装了Docker。 服务安装 Drone支持集成很多代码托管平台，包括GitHub、GitLab、Gitea等，以下以GitHub为例： 第一步：准备创建一个GitHub的OAuth认证应用这一步主要是为了获取客户端ID和客户端秘钥，Drone服务在启动时候需要指定这两个参数，后续才有权限从GitHub拉取代码等一系列操作： 创建一个可共享秘钥通过openssl命令创建(这一步感觉可以省略，后面会设置Drone服务为”http”方式)：12$ openssl rand -hex 16bea26a2221fd8090ea38720fc445eca6 第二步：下载镜像我们上面说到了Drone是基于Docker的，Drone服务也是如此：1docker pull drone/drone 官网上指定了版本”1”，这里我们默认使用”latest”。 第三步：配置 DRONE_GITHUB_CLIENT_ID，第一步中获取到的客户端ID DRONE_GITHUB_CLIENT_SECRET，第一步中获取到的客户端秘钥 DRONE_RPC_SECRET，第一步中openssl命令创建的共享秘钥 DRONE_SERVER_HOST，Drone服务所在主机域名或者公网IP DRONE_SERVER_PROTO，Drone服务协议，可选”http”和”https” 第四步：启动服务以下是完整的Drone服务运行参数：1234567891011121314docker pull drone/dronedocker run \--volume=/var/lib/drone:/data \--env=DRONE_GITHUB_CLIENT_ID=XXX \--env=DRONE_GITHUB_CLIENT_SECRET=XXX \--env=DRONE_RPC_SECRET=bea26a2221fd8090ea38720fc445eca6 \--env=DRONE_SERVER_HOST=47.104.243.84:9001 \--env=DRONE_SERVER_PROTO=http \--publish=9001:80 \--publish=443:443 \--restart=always \--detach=true \--name=drone \drone/drone 映射端口根据实际需要进行调整，执行完该命令后，Drone服务已经运行起来了，我们可以在浏览器中打开http://47.104.243.84:9001，会出现GitHub授权登陆界面：用GitHub授权成功后，可以进入到服务管理页面。 执行器安装 服务启动成功之后我就迫不及待的去GitHub上建了个用来测试的项目”drone-demo”，不用具体的实现就放一个README.md就可以了，并且按照官网文档在项目根目录增加了一个配置文件.drone.yml：1234567891011121314kind: pipelinetype: execname: defaultplatform: os: linux arch: 386steps:- name: build commands: - pwd - ls -latrigger: branch: - master 回到服务管理页面点击”SYNC”，发现”drone-demo”已经在列表中了，我们在列表中点击对应的”ACTIVATE”链接激活该项目，这样才会触发Drone的构建操作。随便更改drone-demo中的代码然后提交上传，再回到管理页面发现已经触发了构建但问题是一直卡在那里不动了：在网上搜了下，发现基本上都说需要安装drone-agent，而且使用docker-compose一次性安装服务和代理，看起来挺靠谱的，但问题是官网上没有代理的相关描述！不管怎么样，我们还是能看出来是缺少了什么导致的，再回到官网细看才发现还需要安装执行器”Runner”，而执行器分为以下几种： Docker Runner，在相关的docker容器中执行构建步骤，比如我们可以根据需要在不同版本的node容器中执行构建 Kubernetes Runner Exec Runner，这个执行器比较特殊，本次就是使用的这个执行器，其他的几个执行器都是可以通过docker容器形式提供服务，这个是以原生的服务提供，具体安装过程和参数配置这里不细说了，官网上已经很详细了，可以参考官网：在Linux安装Exec执行器 SSH Runner Digital Ocean Runner安装并成功启动exec执行器之后，我们发现原先的构建已经成功了：过程也还算顺利，比当初我在使用Jenkins的时候容易多了。如果安装其他的执行器的话可以使用docker-compose，这样服务和执行器可以一起安装比较方便，这里提供一个docker-compose的配置文件以供参考(只包含Drone服务，根据需要自行添加执行器的相关配置)：12345678910111213141516version: '3'services: drone-server: image: drone/drone ports: - 9001:80 container_name: drone volumes: - /var/lib/drone:/data restart: always environment: - DRONE_GITHUB_CLIENT_ID=XXX - DRONE_GITHUB_CLIENT_SECRET=XXX - DRONE_RPC_SECRET=cf51230bedda724d772507cb7140596f - DRONE_SERVER_HOST=47.104.243.84:9001 - DRONE_SERVER_PROTO=http 后记 我现在还只是停留在试用阶段，Drone的很多功能还有待进一步探索，有兴趣的朋友也可以自己试用一下。 参考资料： https://docs.drone.io/ https://www.cntofu.com/book/139/cases/ci/drone.md]]></content>
      <categories>
        <category>运维</category>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>Drone</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019热门技术合集]]></title>
    <url>%2F2019%2F08%2F25%2Fhot-technologies-of-2019%2F</url>
    <content type="text"><![CDATA[以下收集了2019年软件行业各类热门技术盘点的文章，涵盖了前端、后端、运维、数据库等各项热门技术。 2019十大最佳DevOps工具 值得看看，2019年11个受欢迎的JavaScript动画库！ 决胜未来，2019前端开发十大战略性技术布局 盘点2019年Java开发中7项主流、热门的IT技术！ 2019年必知的10大顶级Python库 2019年CSS的7大趋势与发展 2019年最好的JavaScript图表库 2019数据库趋势报告，最受欢迎的是MySQL]]></content>
      <categories>
        <category>盘点</category>
        <category>2019</category>
      </categories>
      <tags>
        <tag>盘点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你必须懂的前端性能优化]]></title>
    <url>%2F2019%2F08%2F20%2Ffront-end-performance-optimization-what-you-must-konw%2F</url>
    <content type="text"><![CDATA[本文作者从页面加载过程、浏览器缓存策略、CDN、图片优化和渲染优化等几个方面详细介绍了前端的相关概念和优化方法。 从输入URL加载起看方向 首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了 TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件 CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了 我们从输入 URL 到显示页面这个过程中，涉及到网络层面的，有三个主要过程： DNS 解析 TCP 连接 HTTP 请求/响应 对于 DNS 解析和 TCP 连接两个步骤，我们前端可以做的努力非常有限。相比之下，HTTP 连接这一层面的优化才是我们网络优化的核心。HTTP 优化有两个大的方向： 减少请求次数 减少单次请求所花费的时间 浏览器缓存策略 浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下： Memory Cache Service Worker Cache HTTP Cache Push Cache MemoryCacheMemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。浏览器秉承的是“节约原则”，我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。 Service Worker Cacheervice Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。 HTTP Cache对一条http get 报文的基本缓存处理过程包括7个步骤： 接收 解析 查询，缓存查看是否有本地副本可用，如果没有，就获取一份副本 新鲜度检测， 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。 创建响应，缓存会用新的首部和已缓存的主体来构建一条响应报文。 发送，缓存通过网络将响应发回给客服端。 日志 强缓存强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。 是否足够新鲜时期：通过 Expires: XXXX XXX XXX GMT （绝对日期时间，http/1.0） 或者 Cache-Control:max-age=XXXX （相对日期时间，http/1.1）在文档标明过期日期。 Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。 关键字理解public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为默认值。 no-store与no-cache，no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。 协商缓存协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。 协商缓存的实现：从 Last-Modified 到 Etag，详细自己百度，这里不再详细展开。 HTTP缓存决策当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。 Push CachePush Cache 是指 HTTP2 在 server push 阶段存在的缓存。 Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。 Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。 CDN了解一番 CDN 的核心点有两个，一个是缓存，一个是回源。 “缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。CDN 往往被用来存放静态资源。所谓“静态资源”，就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。而“动态资源”，顾名思义是需要后端实时动态生成的资源，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。 那“非纯静态资源”呢？它是指需要服务器在页面之外作额外计算的 HTML 页面。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它和业务服务器的操作耦合，我们把它丢到CDN 上显然是不合适的。 另外，CDN的域名必须和主业务服务器的域名不一样，要不，同一个域名下面的Cookie各处跑，浪费了性能流量的开销，CDN域名放在不同的域名下，可以完美地避免了不必要的 Cookie 的出现！ 图片优化 二进制位数与色彩的关系在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。 一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。 计算图片大小对于一张 100 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 1 * 4 / 1024）。但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了： 减少像素点 减少每个像素点能够显示的颜色 图片类型要点PEG/JPG 特点：有损压缩、体积小、加载快、不支持透明,JPG 最大的特点是有损压缩。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。但当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。 PNG 特点：无损压缩、质量高、体积大、支持透明，PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。8 和 24，这里都是二进制数的位数。按照我们前置知识里提到的对应关系，8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是体积太大。 SVG 特点：文本文件、体积小、不失真、兼容性好，SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。 Base64 特点：文本文件、依赖编码、小图标解决方案，Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。 WebP 特点：年轻的全能型选手，WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。但是毕竟年轻，兼容性存在一些问题。 渲染优化 客户端渲染在客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。页面上呈现的内容，你在 html 源文件里里找不到——这正是它的特点。 服务端渲染在服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成HTML字符串，然后把它返回给客户端。页面上呈现的内容，我们在 html 源文件里也能找到。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢，也解决了SEO搜索引擎的问题。 浏览器渲染过程解析浏览器的渲染机制一般分为以下几个步骤： 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 在渲染DOM的时候，浏览器所做的工作实际上是： 获取DOM后分割为多个图层 对每个图层的节点计算样式结果（Recalculate style–样式重计算） 为每个节点生成图形和位置（Layout–回流和重布局） 将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘） 图层作为纹理上传至GPU 复合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组） 基于渲染流程的 CSS 优化建议CSS 选择符是从右到左进行匹配的，比如#myList li {}实际开销相当高。 避免使用通配符，只对需要用到的元素进行选择。 关注可以通过继承实现的属性，避免重复匹配重复定义。 少用标签选择器。如果可以，用类选择器替代。 错误：#dataList li{} 正确：.dataList{} 不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。错误：.dataList#title 正确： #title 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。 CSS 的阻塞CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK。我们将 CSS 放在 head 标签里 和尽快 启用 CDN 实现静态资源加载速度的优化。 JS 的阻塞JS 引擎是独立于渲染引擎存在的。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 DOM渲染优化先了解回流和重绘 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。 重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。 例子剖析123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;DOM操作测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123for(var count=0;count&lt;10000;count++)&#123; document.getElementById('container').innerHTML+='&lt;span&gt;我是一个小测试&lt;/span&gt;' //我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，额外开销&#125; 进化一：12345// 只获取一次containerlet container = document.getElementById('container')for(let count=0;count&lt;10000;count++)&#123; container.innerHTML += '&lt;span&gt;我是一个小测试&lt;/span&gt;'&#125; 进化二：123456789//减少不必要的DOM更改let container = document.getElementById('container')let content = ''for(let count=0;count&lt;10000;count++)&#123; // 先对内容进行操作 content += '&lt;span&gt;我是一个小测试&lt;/span&gt;'&#125; // 内容处理好了,最后再触发DOM的更改container.innerHTML = content 事实上，考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。 在 DOM Fragment 中，DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。 进化三：123456789101112let container = document.getElementById('container')// 创建一个DOM Fragment对象作为容器let content = document.createDocumentFragment()for(let count=0;count&lt;10000;count++)&#123; // span此时可以通过DOM API去创建 let oSpan = document.createElement("span") oSpan.innerHTML = '我是一个小测试' // 像操作真实DOM一样操作DOM Fragment对象 content.appendChild(oSpan)&#125;// 内容处理好了,最后再触发真实DOM的更改container.appendChild(content) 进化四：当涉及到过万调数据进行渲染，而且要求不卡住画面，如何解决？如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; 控件 &lt;/ul&gt; &lt;script&gt; setTimeout(() =&gt; &#123; // 插入十万条数据 const total = 100000 // 一次插入 20 条，如果觉得性能不好就减少 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector('ul') function add() &#123; // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment() for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement('li') li.innerText = Math.floor(Math.random() * total) fragment.appendChild(li) &#125; ul.appendChild(fragment) countOfRender += 1 loop() &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; window.requestAnimationFrame(add) &#125; &#125; loop() &#125;, 0) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 注意：若您想要在下次重绘时产生另一个动画画面，您的回调例程必须调用 requestAnimationFrame()。 Event Loop我们先了解javascript运行机制，对渲染是大有帮助的，可以看我历史文章JavaScript运行机制，Javascript运行机制深入。 事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。 例子分析：12// task是一个用于修改DOM的回调setTimeout(task, 0) 上面代码，现在 task 被推入的 macro 队列。但因为 script 脚本本身是一个 macro 任务，所以本次执行完 script 脚本之后，下一个步骤就要去处理 micro 队列了，再往下就去执行了一次 render,必须等待下一次的loop。1Promise.resolve().then(task) 上面代码，我们结束了对 script 脚本的执行，是不是紧接着就去处理 micro-task 队列了？micro-task 处理完，DOM 修改好了，紧接着就可以走 render 流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。 当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。 上面说了重绘与回流，Event loop，但很多人不知道的是，重绘和回流其实和 Event loop 有关。 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 节流与防抖 当用户进行滚动，触发scroll事件，用户的每一次滚动都将触发我们的监听函数。函数执行是吃性能的，频繁地响应某个事件将造成大量不必要的页面计算。因此，我们需要针对那些有可能被频繁触发的事件作进一步地优化。节流与防抖就很有必要了！ 详细看历史文章防抖动与节流。 本文转自https://segmentfault.com/a/1190000019897234。]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL风格指南]]></title>
    <url>%2F2019%2F08%2F18%2Fsql-style-guide%2F</url>
    <content type="text"><![CDATA[您好!我是Matt Mazur，是一名数据分析师，曾在多家初创公司工作，帮助他们利用数据发展业务。本指南试图记录我对格式化SQL的偏好，以期对其他人有所帮助。如果您或您的团队还没有SQL样式指南，那么这可能是一个很好的起点，您可以根据自己的喜好采用和更新。 另外，我是一个意见偏激者，所以如果您不同意任何一点，给我一个便条，我很乐意去探讨。 如果您对这个主题感兴趣，您可能同样会对我的Matt on Analytics新闻稿件和我写的关于分析学和数据分析的博客感兴趣。 示例 下面是一个非常重要的查询，让您能够了解这个风格指南在实践中是什么样子的：12345678910111213141516171819202122232425262728293031323334353637383940with hubspot_interest as ( select email, timestamp_millis(property_beacon_interest) as expressed_interest_at from hubspot.contact where property_beacon_interest is not null), support_interest as ( select email, created_at as expressed_interest_at from helpscout.conversation inner join helpscout.conversation_tag on conversation.id = conversation_tag.conversation_id where tag = 'beacon-interest'), combined_interest as ( select * from hubspot_interest union all select * from support_interest),final as ( select email, min(expressed_interest_at) as expressed_interest_at from combined_interest group by email)select * from final 准则 使用小写SQL它和大写的SQL一样可读，您不必一直按住SHIFT键。12345678-- Goodselect * from users-- BadSELECT * FROM users-- BadSelect * From users 单行查询与多行查询当你进行以下查询时才可以将所有SQL放到同一行： 所有列（*）或选择1或2列 而且在您的查询中没有额外的复杂性1234567891011-- Goodselect * from users-- Goodselect id from users-- Goodselect id, email from users-- Goodselect count(*) from users 原因很简单，当所有东西都在一条线上时，仍然很容易阅读。但是，一旦您开始添加更多的列或更复杂的列，如果它位于多行上，则更容易阅读：1234567891011-- Goodselect id, email, created_atfrom users-- Goodselect *from userswhere email = 'example@domain.com' 对于具有1列或2列的查询，可以将列放在同一行上。对于3+列，将每个列名称放在自己的行上，包括第一项：12345678910111213141516171819202122232425-- Goodselect id, emailfrom userswhere email like '%@gmail.com'-- Goodselect user_id, count(*) as total_chargesfrom chargesgroup by user_id-- Goodselect id, email, created_atfrom users-- Badselect id, email, created_atfrom users-- Badselect id, emailfrom users 所有内容左对齐123456789-- Goodselect id, emailfrom userswhere email like '%@gmail.com'-- Badselect id, email from users where email like '%@gmail.com' 使用单引号一些SQL方言（如BigQuery）支持使用双引号，但对于大多数方言来说，双引号最终会引用列名。因此，最好使用单引号：123456789-- Goodselect *from userswhere email = 'example@domain.com'-- Badselect *from userswhere email = "example@domain.com" 使用!=而不是只是因为!=读起来像“不等于”，这更接近于我们怎么大声说出来。1234-- Goodselect count(*) as paying_users_countfrom userswhere plan_name != 'free' 逗号应在行尾1234567891011-- Goodselect id, emailfrom users-- Badselect id , emailfrom users 缩进Where条件当只有一个Where条件时，请将其与where保持在同一行：123select emailfrom userswhere id = 1234 如果存在多个条件，则将每个级别缩进到比where更深的一个级别。将逻辑运算符放在前一个条件的末尾：12345select id, emailfrom userswhere created_at &gt;= '2019-03-01' and vertical = 'work' 避免括号内有空格123456789-- Goodselect *from userswhere id in (1, 2)-- Badselect *from userswhere id in ( 1, 2 ) 将in查询值的长列表分隔为多个缩进行123456789-- Goodselect *from userswhere email in ( 'user-1@example.com', 'user-2@example.com', 'user-3@example.com', 'user-4@example.com') 表名应该是蛇形连接复数形式12345678910111213-- Goodselect id, email, timestamp_trunc(created_at, month) as signup_monthfrom users-- Badselect id, email, timestamp_trunc(created_at, month) as SignupMonthfrom users 列名约定 布尔型字段应以is_，has_或does_开头，如：is_customer, has_unsubscribed等。 日期型字段应以_date结尾，如：report_date。 日期时间型字段应以_at结尾，如：created_at, posted_at等。 列顺序约定首先放置主键，接着是外键，然后放置所有其他列。如果表中有任何系统列(created_at, updated_at, is_deleted等)，则放到最后。12345678910111213-- Goodselect id, name, created_atfrom users-- Badselect created_at, name, id,from users 内连接中包含inner最好是显式的，以便连接类型清晰明了：12345678910111213-- Goodselect email, sum(amount) as total_revenuefrom usersinner join charges on users.id = charges.user_id-- Badselect email, sum(amount) as total_revenuefrom usersjoin charges on users.id = charges.user_id 对于联接条件，将首先引用的表放在紧邻on之后这样做可以更容易地确定连接是否会导致结果分散：123456789101112131415161718-- Goodselect ...from usersleft join charges on users.id = charges.user_id-- primary_key = foreign_key --&gt; one-to-many --&gt; fanout select ...from chargesleft join users on charges.user_id = users.id-- foreign_key = primary_key --&gt; many-to-one --&gt; no fanout-- Badselect ...from usersleft join charges on charges.user_id = users.id 单个联接条件应与join在同一行上12345678910111213141516-- Goodselect email, sum(amount) as total_revenuefrom usersinner join charges on users.id = charges.user_idgroup by email-- Badselect email, sum(amount) as total_revenuefrom usersinner join chargeson users.id = charges.user_idgroup by email 当有多个连接条件时，将每个条件放置在各自的缩进行上：123456789-- Goodselect email, sum(amount) as total_revenuefrom usersinner join charges on users.id = charges.user_id and refunded = falsegroup by email 避免表别名12345678910111213-- Goodselect email, sum(amount) as total_revenuefrom usersinner join charges on users.id = charges.user_id-- Badselect email, sum(amount) as total_revenuefrom users uinner join charges c on u.id = c.user_id 唯一的例外是，当您需要多次联接到一个表上并需要区分它们时。 如非必须不要包含表名1234567891011-- Goodselect id, namefrom companies-- Badselect companies.id, companies.namefrom companies 总是重命名聚合和函数包装的参数1234567891011121314151617-- Goodselect count(*) as total_usersfrom users-- Badselect count(*)from users-- Goodselect timestamp_millis(property_beacon_interest) as expressed_interest_atfrom hubspot.contactwhere property_beacon_interest is not null-- Badselect timestamp_millis(property_beacon_interest)from hubspot.contactwhere property_beacon_interest is not null 确保布尔条件是显示的1234567-- Goodselect * from customers where is_cancelled = trueselect * from customers where is_cancelled = false-- Badselect * from customers where is_cancelledselect * from customers where not is_cancelled 使用as定义列别名12345678910111213-- Goodselect id, email, timestamp_trunc(created_at, month) as signup_monthfrom users-- Badselect id, email, timestamp_trunc(created_at, month) signup_monthfrom users 用列名而不是序号做分组1234567891011-- Goodselect user_id, count(*) as total_chargesfrom chargesgroup by user_id-- Badselect user_id, count(*) as total_chargesfrom chargesgroup by 1 使用列别名12345678910111213-- Goodselect timestamp_trunc(com_created_at, year) as signup_year, count(*) as total_companiesfrom companiesgroup by signup_year-- Badselect timestamp_trunc(com_created_at, year) as signup_year, count(*) as total_companiesfrom companiesgroup by timestamp_trunc(com_created_at, year) 分组列应置于最前12345678910111213-- Goodselect timestamp_trunc(com_created_at, year) as signup_year, count(*) as total_companiesfrom companiesgroup by signup_year-- Badselect count(*) as total_companies, timestamp_trunc(com_created_at, year) as signup_yearfrom mysql_helpscout.helpscout_companiesgroup by signup_year 对齐case/when语句每个when都应该在自己的行上（case所在行没有任何内容），并且应该缩进比case行深一层。then可以和when在同一行上或者在下一行，这样做只是为了保持一致。123456789101112131415161718192021222324-- Goodselect case when event_name = 'viewed_homepage' then 'Homepage' when event_name = 'viewed_editor' then 'Editor' end as page_namefrom events-- Good tooselect case when event_name = 'viewed_homepage' then 'Homepage' when event_name = 'viewed_editor' then 'Editor' end as page_namefrom events-- Bad select case when event_name = 'viewed_homepage' then 'Homepage' when event_name = 'viewed_editor' then 'Editor' end as page_namefrom events 使用通CTEs而非子查询避免子查询，CTE（通用表表达式）将使您的查询更容易阅读和解释。使用CTE时，请用新行填充查询。如果使用任何CTE，请始终在末尾使用名为final的CTE，并选择* from final。这样，您就可以快速检查查询中用于调试结果的其他CTE的输出。关闭CTE括号应使用与WITH和CTE名称相同的缩进级别。12345678910111213141516171819202122232425262728293031-- Goodwith ordered_details as ( select user_id, name, row_number() over (partition by user_id order by date_updated desc) as details_rank from billingdaddy.billing_stored_details),final as ( select user_id, name from ordered_details where details_rank = 1)select * from final-- Badselect user_id, namefrom ( select user_id, name, row_number() over (partition by user_id order by date_updated desc) as details_rank from billingdaddy.billing_stored_details) rankedwhere details_rank = 1 使用有意义的CTE名称12345-- Goodwith ordered_details as (-- Badwith d1 as ( 窗口函数您可以将其全部保留在自己的行中，也可以根据其长度将其拆分为多个：12345678910111213141516-- Goodselect user_id, name, row_number() over (partition by user_id order by date_updated desc) as details_rankfrom billingdaddy.billing_stored_details-- Goodselect user_id, name, row_number() over ( partition by user_id order by date_updated desc ) as details_rankfrom billingdaddy.billing_stored_details 感谢 本风格指南灵感来源于： Fishtown Analytics’ dbt Style Guide KickStarter’s SQL Style Guide GitLab’s SQL Style Guide 向Peter Butler、Dan Wyman、Simon Ouderkirk、Alex Cano、Adam Stone、Brian Kim和Claire Carroll提供关于本指南的反馈意见表示感谢。 本文译自https://github.com/mattm/sql-style-guide#guidelines]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个设计模式-前言]]></title>
    <url>%2F2019%2F07%2F22%2Fdaily-design-pattern-preface%2F</url>
    <content type="text"><![CDATA[设计模式(Design Patterns)是前辈们总结出的一套可以反复使用的理论。它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列复杂的问题。1995年GoF四人合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了23种设计模式，这本书成为了设计模式领域的“圣经”。本系列文章在结合自己理解的基础上介绍这些设计模式，同时给出Java和TypeScript两种语言的应用示例。 6大设计原则 《设计模式》一书中首先提出了6大设计原则，接下来的23种设计模式就是基于这些原则总结出的一套方法论。在学习和理解这些原则和设计模式的时候，我们可能会发现设计模式并不是什么高深的技术，在工作的过程中或多或少都已经有所接触或者使用过。 单一职责原则单一职责原则(Single Responsibility Principle,SRP)，原文对它的解释是“There should never be more than one reason for a class to change”即一个对象不应该有多个引起它变化的原因。这句话看起来很简单，但具体应该怎么理解呢？从面向对象角度来说对象由一系列属性和方法组成，引起对象变化也就是通过调用方法改变属性，那么这个原则简单来说就是一个类应当仅包含某一类功能的方法。这样去设计类的确很好，可以提高可读性、降低类的复杂度等。但实际经验告诉我们很少有人会这么做，因为工作过程中会综合考虑工作量以及员工技术水平等因素，往往都会“违背”这一原则。另外，“职责”是一个无法量化的概念，很难依据标准去划分，我们在工作过程中更多的是面向接口编程，应当尽可能保证接口的单一职责和降低类的复杂度。举个例子，我们在遍历集合时经常用到的Iterator接口，从JDK1.2开始仅包含三个方法，直到JDK1.8才增加了一个新的方法：123456789101112131415161718public interface Iterator&lt;E&gt; &#123; // jdk1.2-jdk1.7 boolean hasNext(); E next(); void remove(); // jdk1.8 boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 我们可以看出，一个职责分明、结构清晰的接口可以极大的提升代码的可重用性。 里氏替换原则里氏替换原则(Liskov Substitution Principle,LSP)，这是Liskov于1987年提出关于继承的原则“Inheritance should ensure that any property proved about supertype objects also holds for subtype objects.”即继承必须确保父类所拥有的 在子类中仍然成立，这样父类能出现的地方子类就可以出现。 依赖倒置原则依赖倒置原则(Dependency Inversion Principle,DIP)，它的原始定义是“High level modules should not depend upon low level modules.Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.”归根结底就是实现应该依赖于抽象，再具体点就是在单一职责种提到的“面向接口编程”。 接口隔离原则接口隔离原则(Interface Segregation Principle,ISP)，它的其中一种定义是“The dependency of one class to another one should depend on the smallest possible interface.”即类间的依赖关系应该建立在最小的接口上，这就要求我们定义出的接口需要保证“原子性”，是不是感觉和“单一职责原则”是相同的？其实不然，单一职责强调的是某一类功能的聚合而接口隔离则需要保证接口“干净”没有多余的方法。比如我们简单定义了如下动物接口，并且有两个实现类：12345678910111213141516171819202122232425262728public interface IAnimal &#123; void eat(); void makeTools();&#125;public class People implements IAnimal &#123; @Override public void eat() &#123; System.out.println("I am eating."); &#125; @Override public void makeTools() &#123; System.out.println("I can make tools."); &#125;&#125;public class Ant implements IAnimal &#123; @Override public void eat() &#123; System.out.println("I am eating."); &#125; @Override public void makeTools() &#123; // do noting &#125;&#125; 所有动物都会吃东西，但只有人和部分动物会制造工具，在很多其他动物的实现类中这个方法是多余的，因此这个接口不满足接口隔离原则，但它满足单一职责原则。为了能够满足接口隔离原则，我们可以将makeTools方法提取到一个单独的接口中，其他类根据需要去实现这两个接口：123456public interface IAnimal &#123; void eat();&#125;public interface IToolsMaker &#123; void makeTools();&#125; 迪米特法则迪米特法则(Law of Demeter，LoD)也称为最少知识原则(Least Knowledge Principle，LKP)，意思是类与类之间应减少依赖，它提出的初衷是为了降低类之间的耦合。 开闭原则开闭原则的定义为“Software entities like classes， modules and functions should be open for extension but closed for modifications.”即一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。这个原则要求我们通过扩展来实现变化，而不是修改已有代码。]]></content>
      <categories>
        <category>编程</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TypeScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IDEA中使用FindBugs]]></title>
    <url>%2F2019%2F07%2F20%2Ffindbugs%2F</url>
    <content type="text"><![CDATA[FindBugs用来静态分析和查找Java代码中存在的Bugs，它的运行需要依赖1.7或更高版本的JRE(或JDK)，但是它可以分析从1.0到1.8各个版本的JDK编译出的程序，是一个基于字节码的工具。本文简单介绍了如何在IDEA中使用FindBugs，并对FindBugs的相关概念作出说明。 IDEA中安装使用 安装 在IDEA中ctrl+alt+s打开设置面板，找到”Plugins”选项； 然后选择”Browse repositories…”在搜索框中输入”findbugs”查找插件，结果列表中选择”FindBugs-IDEA”并安装； 安装完成后重启IDEA方可生效。 使用 重启后，可以在下列截图中看到最下方工具栏中多出了”FindBugs-IDEA”一项，同时右键选项中也多出了”FindBugs”选项。截图分成了4列，其中第一列中是FindBugs工具栏，可以选择分析范围和分析结果分组；第二列是分析结果列，在该列中选择一个分析出来的Bug后，第三列和第四列会相应展示这个Bug出现的位置以及Bug的详细说明。 说明分析范围 当前文件 当前类(对于含内部类的文件，可以选择只分析光标所在类) 当前包 当前模块 当前工程 指定范围 所有修改的文件(需要结合VCS) changelist中的类(需要结合VCS) 结果分组 根据Bug分类分组，这也是默认的分组 根据类分组 根据包分组 根据Bug严重级别分组，工作中推荐使用的，可以相应优先处理严重级别较高的Bug。 严重级别 Of Concren - 建议, 如果遵循能更好的完善代码 Troubling - 不好的, 可能会引发不良后果 Scary - 严重问题, 在某种情况下一定会出现问题 Scariest - 非常严重, 已经影响到当前程序功能 Bug类型及示例 FindBugs定义了很多详细的Bug类型，这里针对每个大类仅列出一些比较常见的类型，完整列表请参考官网FindBugs Bug Descriptions。 Bad practice - 不好的习惯(仔细看下来有些Bug会导致程序错误，因此也需要谨慎对待) 比较字符串时使用”==”或”!=” 不可变类成员变量没有声明为”final” Correctness - 正确性 方法参数顺序颠倒，比如Preconditions.checkNotNull(“message”, message) 字符串格式化时缺少参数，比如formatter.format(“%s %s”, “a”) Experimental - 实验性的 没有使用try-finally进行关闭IO流 Internationalization - 国际化(在支持多语言时需要关注) 字符和字节数组转换时没有指定字符集 Malicious code vulnerability - 恶意代码漏洞 成员变量在一些情况下应声明为”final”但没有 Multithreaded correctness - 多线程正确性 多线程情况下可能存在双重检查锁的情况(单例模式下需注意) 使用静态的日期格式化相关对象，如：SimpleDateFormat Performance - 性能 在循环体重使用”+”号连接字符串，我们知道平时字符串变量使用”+”连接时编译器会进行优化为一个StringBuilder对象进行字符串拼接，但在循环体中会创建多个StringBuilder对象，大大增加了时间和空间的开销 对于没有引用父对象的子类没有定义为”static”，很好理解，这种做法会无意义的增加父对象的大小，并且父对象会持有无效的引用 定义了从未被使用的成员变量 Security - 安全 硬编码或者使用空的数据库密码 动态SQL语句没有使用”prepared statement” Dodgy code - 可疑代码 冗余的空值检查 Swich语句块缺少Default语句 在可能导致空指针异常的地方没有进行非空检查 后记 在IDEA中使用FindBugs是如此简单，但起到的作用真的太大了。在平时的工作中，由于各种因素程序中难免会存在不规范甚至错误的地方，有些错误只是一直没有暴露出来而已，等到真正暴露的时候已经为时已晚。所以我们应该尽可能的去避免这种情况的发生，FindBugs就是一个很好的选择。当然，我们不能完全依赖于工具，还应当做好代码审查以及测试等工作，工具只是一种补充手段。]]></content>
      <categories>
        <category>工具</category>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工具</tag>
        <tag>FindBugs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK版本历史]]></title>
    <url>%2F2019%2F06%2F24%2Fjdk-versions%2F</url>
    <content type="text"><![CDATA[记录了JDK的发展历史以及各版本的主要特性，从1.7版本开始会结合示例进行说明和讲解，本文将持续进行收集和更新。 JDK1.0 简介1996年1月23日发布，这是Java语言的第一个正式版本。 新特性 Java虚拟机 Applet AWT JDK1.1 简介1997年2月19日发布。 新特性 JAR文件格式 JDBC JavaBeans RMI 内部类 反射 JDK1.2 简介1998年12月4日发布，工程代号Playground(竞技场)，这是一个里程碑式的版本，它将Java技术体系分为3个方向，就是我们熟知的面向桌面应用开发的J2SE(Java 2 Platform, Standard Edition)、面向企业级开发的J2EE(Java 2 Platform, Enterprise Edition)和面向移动端开发的J2ME(Java 2 Platform, Micro Edition)。 新特性 EJB Java Plug-in Java IDL Swing 内置了JIT(Just In Time)编译器 增加strictfp关键字 Collections集合类 JDK1.3 简介2000年5月8日发布，工程代号Kestrel(美洲红隼)，从这个版本开始Sun大约每隔两年发布一个以动物命名JDK的主版本，期间发布的修正版本以昆虫命名。如修正版本1.3.1工程代号为Ladybird(瓢虫)。 新特性 JNDI 数学运算和Timer API 改进JAVA 2D，新增大量API 新增JavaSound类库 JDK1.4 简介2002年2月13日发布，工程代号Merlin(灰背隼)。与此同时，微软的.NET Framework也在此时发布，它在技术实现和目标客户上都与Java有很多相近之处。 新特性 NIO 正则表达式 异常链 日志类 XML解析器和XLST转换器 JDK5 简介2004年9月30日发布，工程代号Tiger(老虎)。从1.5.0开始调整命名(也可以说是出现命名分支)，产品概念上是“5.0”，对于大部分开发者来说习惯了“1.”的叫法，所以“1.5.0”(或1.5)依然被延续下来(参见：Version 1.5.0 or 5.0?)，这个版本在语法上作了很大的改进。 新特性 改进Java的内存模型(Java Memory Modal，JMM) 提供java.util.concurrent并发包 自动拆装箱 泛型 动态注解 枚举 可变长参数 遍历循环(foreach循环) JDK6 简介2006年12月11日发布，工程代号Mustang(野马)。结束了J2EE、J2SE和J2ME的命名方式，启用Java SE6、Java EE 6和Java ME 6的命名方式。 新特性 动态语言支持(通过内置Mozilla JavaScript Rhino引擎实现) 提供编译API 微型HTTP服务器API 改进了锁与同步、垃圾收集和类加载等 JDK7 简介2009年2月19日发布，工程代号Dolphin(海豚)。同年4月20日，Oracle正式收购Sun公司, JDK开始开源(OpenJDK)，这注定是一个多事之秋，最开始规划的很多内容包括Lambda表达式等都延迟到了JDK1.8才实现；这也是Java的一次机遇，Oracle收购Sun公司后，取得了三大虚拟机中的其中两个：JRockit(BEA公司)和HotSpot(Sun公司，另外一个为IBM的J9)，宣布把这两个优秀的虚拟机互相取长补短，因此在随后的一个版本中虚拟机技术将会产生巨大的变化。 新特性 提供新的G1收集器从JDK1.3开始，HotSpot团队一直努力朝着高效收集、减少停顿(STW: Stop The World)的方向努力，贡献了从串行到并行再到CMS(Concurrent Mark-Sweep Collector)乃至最新的G1在内的一系列优秀的垃圾收集器。G1(Garbage First)最大的特点是引入分区的思想，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。&nbsp;JDK默认垃圾回收器查看方法： 1java -XX:+PrintCommandLineFlags -version Try-With-Resources操作的类只要是实现了AutoCloseable接口就可以在try语句块退出的时候自动调用close方法关闭流资源。 123456try ( InputStream is = new FileInputStream("source.txt"); OutputStream os = new FileOutputStream("target.txt")) &#123; // ...&#125;// 代码块执行结束时JVM自动关闭流 switch支持字符串判断条件 123456String str = "xxx";switch (str)&#123; case "xxx": //... break;&#125; 泛型推导 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 捕获多个异常Java7以前在一个方法抛出多个异常时，只能一个个的catch，这样代码会有多个catch,显得很不友好，现在只需一个catch语句，多个异常类型用”|”隔开。 12345try &#123; result = field.get(obj);&#125; catch (IllegalArgumentException | IllegalAccessException e) &#123; e.printStackTrace();&#125; 数字中可添加分隔符Java7中支持在数字中间增加’_‘作为分隔符，分隔长int以及long（也支持double,float），显示更直观，如（12_123_456）。下划线只能在数字中间，编译时编译器自动删除数字中的下划线。 1234int intOne = 1_000_000;long longOne = 1_000_000;double doubleOne = 1_000_000;float floatOne = 1_000_000; 增加二进制表示Java7前支持十进制（123）、八进制（0123）、十六进制（0X12AB） 123int binary = 0b0001_1001;System.out.println("binary is :"+binary);// binary is :25 JDK8 简介2014年3月18日发布，时隔五年，这是Oracle收购Sun后发布的第一个版本，也是比较重要的一个版本。完整新特性参考：What’s New in JDK 8 新特性接口默认方法1234567interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; Lambda表达式Lambda表达式为我们创建匿名对象提供了更简洁的语法：1Collections.sort(names, (a, b) -&gt; b.compareTo(a)); 函数式接口“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。为了确保接口达到这个要求可以给接口添加@FunctionalInterface注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候会报错：1234567@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert("123");System.out.println(converted); // 123 JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上，接下来我们看看这些接口： Predicate接口Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： 12345678910Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test("foo"); // truepredicate.negate().test("foo"); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Function接口Function接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： 1234Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply("123"); // "123" Supplier接口Supplier接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new Person Consumer接口Consumer接口表示执行在单个参数上的操作。 12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println("Hello, " + p.firstName);greeter.accept(new Person("Luke", "Skywalker")); Comparator接口Comparator是老Java中的经典接口，Java 8在此之上添加了多种默认方法： 1234567Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person("John", "Doe");Person p2 = new Person("Alice", "Wonderland");comparator.compare(p1, p2); // &gt; 0comparator.reversed().compare(p1, p2); // &lt; 0 Optional接口Optional不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：Optional被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。 1234567Optional&lt;String&gt; optional = Optional.of("bam");optional.isPresent(); // trueoptional.get(); // "bam"optional.orElse("fallback"); // "bam"optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // "b" Stream接口java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。首先看看Stream是怎么用，首先创建实例代码的用到的数据List： 123456789List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();stringCollection.add("ddd2");stringCollection.add("aaa2");stringCollection.add("bbb1");stringCollection.add("aaa1");stringCollection.add("bbb3");stringCollection.add("ccc");stringCollection.add("bbb2");stringCollection.add("ddd1"); Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作： Filter 过滤过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。 123456 stringCollection .stream() .filter((s) -&gt; s.startsWith("a")) .forEach(System.out::println);// "aaa2", "aaa1" Sort排序排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。 1234567 stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith("a")) .forEach(System.out::println);// "aaa1", "aaa2" 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的。 12 System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map映射中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。 1234567 stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1" Match匹配Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。 1234567891011121314151617181920 boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith("a"));System.out.println(anyStartsWithA); // trueboolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith("a"));System.out.println(allStartsWithA); // falseboolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith("z"));System.out.println(noneStartsWithZ); // true Count计数计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。 1234567 long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith("b")) .count();System.out.println(startsWithB); // 3 Reduce规约这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的： 12345678 Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + "#" + s2);reduced.ifPresent(System.out::println);// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2" 并行Streams前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。下面的例子展示了是如何通过并行Stream来提升性能：首先我们创建一个没有重复元素的大表 123456 int max = 1000000;List&lt;String&gt; values = new ArrayList&lt;&gt;(max);for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString());&#125; 然后我们计算一下排序这个Stream要耗时多久 串行排序： 12345678910long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format("sequential sort took: %d ms", millis));// 串行耗时: 899 ms 并行排序： 12345678910long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format("parallel sort took: %d ms", millis));// 并行排序耗时: 472 ms 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。 Map前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。 1234567Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, "val" + i);&#125;map.forEach((id, val) -&gt; System.out.println(val)); 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。下面的例子展示了map上的其他有用的函数： 1234567891011map.computeIfPresent(3, (num, val) -&gt; val + num);map.get(3); // val33map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9); // falsemap.computeIfAbsent(23, num -&gt; "val" + num);map.containsKey(23); // truemap.computeIfAbsent(3, num -&gt; "bam");map.get(3); // val33 接下来展示如何在Map里删除一个键值全都匹配的项 12345map.remove(3, "val3");map.get(3); // val33map.remove(3, "val33");map.get(3); // null 另外一个有用的方法 1map.getOrDefault(42, "not found"); // not found 对Map的元素做合并也变得很容易了： 12345map.merge(9, "val9", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9map.merge(9, "concat", (value, newValue) -&gt; value.concat(newValue));map.get(9); Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 方法与构造函数引用上面的Converter还可以通过静态方法引用来实现：123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert("123");System.out.println(converted); // 123 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： 1234567891011class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 接下来我们指定一个用来创建Person对象的对象工厂接口： 123 interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125; 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： 12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create("Peter", "Parker"); 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 Date Time APIJava 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样：12345678LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY 标准Base64编码/解码移除持久代(PermGen) JDK9 简介 2017年9月22日发布，不久之前Oracle宣布将Java的发布周期改为每六个月一次，也就是之后每年的3月份和9月份都会发布一个新的版本。完整特性参考：What’s New in Oracle JDK 9 新特性 模块化(Modularity) REPL(Read-eval-print-loop，交互式解析器)工具JShell 轻量级Json Api 提供了消息发布订阅框架 私有接口方法 JDK10 简介2018年3月20日发布，完整特性参见：Java Language Updates 新特性 局部变量类型推断 1var x = new ArrayList&lt;String&gt;(); 垃圾收集器接口 向G1引入并行Full GC 在备用内存设备上分配堆内存。允许 HotSpot 虚拟机在备用内存设备上分配 Java 对象堆 基于Java的JIT编译器（试验版本） JDK11 简介2018年9月26日发布，这是自1.8版本以后又一个LTS(Long-Term-Support，长期支持，每三年发布一次)版本，完整特性参考What’s New in JDK 11。 新特性 ZGC(Z Garbage Collector，实验性)，可扩展低延迟 Epsilon无操作垃圾回收器（Epsilon 垃圾回收器，又被称为”No-Op”回收器） HTTP Client 移除了很多包和模块，比如JavaFX、JMC等 JDK12 简介2019年3月20日发布，完整特性参考What’s New in JDK 12 新特性 JVM常量API Switch表达式 JDK13 简介2019年9月17日发布，完整特性参考What’s New in JDK 13 新特性 core-libs/java.nio 增加方法FileSystems.newFileSystem(Path, Map&lt;String, ?&gt;) 新的java.nio.ByteBuffer批量获取/放置方法无需考虑缓冲区位置即可传输字节 core-libs/java.util:i18n 支持Unicode 12.1 hotspot/gc JEP 351中的ZGC不提交未使用的内存 增加标记启用ZGC下标记-XXSoftMaxHeapSize ZGC最大管理堆大小从4TB增加到16TB JDK14 简介2020年3月19日发布，完整特性参考What’s New in JDK 14 参考资料： https://www.oracle.com/technetwork/java/javase/overview/index.html https://blog.csdn.net/fenglllle/article/details/81975222 https://blog.csdn.net/u014209205/article/details/79718689 https://www.jianshu.com/p/0bf8fe0f153b]]></content>
      <categories>
        <category>编程</category>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CSS代码片段]]></title>
    <url>%2F2019%2F06%2F11%2Fcss-snippet%2F</url>
    <content type="text"><![CDATA[主要记录了一些常用的样式代码片段和实现效果，将持续进行收集和更新。 外层盒阴影 盒阴影在网页中比较常用，能够很好的组织和区分各个模块。以下利用CSS3的box-shadown实现，具体参数含义参考box-shadown参数说明 代码 12345.outer-shadow &#123; -webkit-box-shadow: 2px 2px 10px 2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 2px 2px 10px 2px rgba(0, 0, 0, 0.52); box-shadow: 2px 2px 10px 2px rgba(0, 0, 0, 0.52);&#125; 效果 透明 在一些地方经常需要用到透明字体，比如输入框的占位符等，下面给出了适应于不同浏览器的实现。 代码 123456.transparent &#123; filter: alpha(opacity=50); -moz-opacity: 0.5; -khtml-opacity: 0.5; opacity: 0.5;&#125; 效果 列表纸质效果 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ul.box &#123; position: relative; z-index: 1; /* prevent shadows falling behind containers with backgrounds */ overflow: hidden; list-style: none; margin: 0; padding: 0;&#125;ul.box li &#123; position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;&#125;ul.box li:before,ul.box li:after &#123; content: ''; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg);&#125;ul.box li:after &#123; left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg);&#125; 效果 缝合效果 代码 1234567891011121314151617181920212223242526272829303132333435363738p &#123; position: relative; z-index: 1; padding: 10px; margin: 10px; font-size: 21px; line-height: 1.3em; color: #fff; background: lightblue; -webkit-box-shadow: 0 0 0 4px lightblue, 2px 1px 4px 4px rgba(10, 10, 0, .5); -moz-box-shadow: 0 0 0 4px lightblue, 2px 1px 4px 4px rgba(10, 10, 0, .5); box-shadow: 0 0 0 4px lightblue, 2px 1px 6px 4px rgba(10, 10, 0, .5); -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;&#125;p:before &#123; content: ""; position: absolute; z-index: -1; top: 3px; bottom: 3px; left: 3px; right: 3px; border: 2px dashed #fff;&#125;p a &#123; color: #fff; text-decoration: none;&#125;p a:hover,p a:focus,p a:active &#123; text-decoration: underline;&#125; 效果 垂直居中 代码 12345.container &#123; min-height: 10em; display: table-cell; vertical-align: middle;&#125; 效果 文本溢出省略 代码 1234567.text-ellipsis &#123; border: 1px solid lightgray; width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 效果]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用网站集合]]></title>
    <url>%2F2019%2F06%2F11%2Ftools%2F</url>
    <content type="text"><![CDATA[主要记录了一些工具或者参考资料类等常常需要用到的网站，将持续进行收集和更新。 工具箱 oschina在线工具 一个工具箱 toolfk-程序员在线工具大全 编程 在线接口测试 在线正则表达式测试 模拟数据服务 Web开发测试工具集合 30秒掌握JS代码片段 两行代码统计PV 许可证 开源许可证选择 国内第一个开源协议-木兰宽松许可证 排版/转换 复制内容转为Markdown格式 在线格式化 数学公式截图转为latex排版 Unix时间戳 在线二维码生成 Nginx配置文件生成 cron表达式生成器 文字转图片 在线国际化 函数图形，可生成动态演示 AsciiMath，网页工具，可以将 ASCII 字符的公式转为数学字体显示 表格转换为各种格式，支持markdown/json/csv/json等格式 编辑器 在线Markdown编辑器 jsbin-在线编写调试JS jsfiddle-JS在线调试 codepen-前端在线开发，可嵌入到页面，含很多特效源码 codesandbox-前端代码沙盒，可以嵌入到页面 vscode网页版 在线拾色器 在线比较文本差异，支持普通文本、json和xml格式 加密/解密 在线加密/解密 Base64编码 多媒体 在线录屏工具 在线PS 开源视频编辑器 PDF相关功能，包括格式转换等很多功能 去除图片背景 在线画ASCII码框图 趣味 需要我帮你百度吗 演示汉字笔画顺序的JS库 各种绳结打法并配有视频教学 各种表情包收集项目 独角兽公司榜单，实时更新估值超过10亿美元的创业公司 前端技术实现的仿黑客帝国文字雨 参照/文档 HTTP状态码详解 RFC文档 谷歌JS编码规范 Node的API文档 JEP，Java增强提案(JDK Enhancement Proposal) JSDoc中文文档 IntelliJ Platform SDK GitHub官方教程 CSS预处理器stylus Swig文档 JSR，Java规范请求(Java Specification Requests) Java SE官方文档 MDN-Web开发技术文档 教程 菜鸟教程 极客学院 计算机组织导论 黑客工具教程 第九频道，包括很多课程视频 运维学校 免费编程笔记下载 Linux系统免费教程 处理器设计 CPU是怎样工作的 素材 17素材 阿里巴巴矢量图标库 ionicons-图标库 阮一峰整理免费资源合集 SVG格式Logo 千库网 无版权插图库 PPT模板 CSS特效 pixabay免费图片 33个免费图标网站 常用的SVG图标库 搜索引擎 多吉 中文搜索聚合网站 资源 Kindle电子书分享网 开源项目/资源收集分类 Chrome插件整理 静态网站生成器 海盗湾中文网BT资源 jsdelivr，npm/git的JS资源开源CDN 快速查看搜素Linux内核源码 植物画册 网络 wireshark-网络数据包分析 在线测速 anydesk-windows远程桌面连接工具，类似teamview，兼容性更好 学术 龙猫学术导航 在线古籍 鲁迅资料在线检索系统 未完待续…]]></content>
      <categories>
        <category>工具</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
