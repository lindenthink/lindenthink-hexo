<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初探Drone]]></title>
    <url>%2F2020%2F03%2F30%2Ffirst-exploration-of-drone%2F</url>
    <content type="text"><![CDATA[Drone是一个现代化的持续集成和持续交付平台，使繁忙的团队能够自动化他们的构建、测试和发布工作流。上面是官方对Drone的定义，和我们在工作过程中用的Jenkins一样，这是一款开源的CI/CD软件。不过Drone是基于Docker的，这一点也许是它的一大优势，它的所有编译和测试流程都在Docker容器中执行，与Jenkins相比它安装方便配置简单，此外也很容易集成到我们应用中。 在大概了解一番后，我想着试用下看看，于是在网上搜了下，不过发现资料不是很多，而且比较坑的是搜到的文章中部署使用方法和官网描述的不太一致，这一点在具体过程中再细说。没有办法，只能完全参考官网的教程了，以下是具体的过程： 环境准备 我用的是阿里云的ECS，装有CentOS7系统，并且已经安装了Docker。 服务安装 Drone支持集成很多代码托管平台，包括GitHub、GitLab、Gitea等，以下以GitHub为例： 第一步：准备创建一个GitHub的OAuth认证应用这一步主要是为了获取客户端ID和客户端秘钥，Drone服务在启动时候需要指定这两个参数，后续才有权限从GitHub拉取代码等一系列操作： 创建一个可共享秘钥通过openssl命令创建(这一步感觉可以省略，后面会设置Drone服务为”http”方式)：12$ openssl rand -hex 16bea26a2221fd8090ea38720fc445eca6 第二步：下载镜像我们上面说到了Drone是基于Docker的，Drone服务也是如此：1docker pull drone/drone 官网上指定了版本”1”，这里我们默认使用”latest”。 第三步：配置 DRONE_GITHUB_CLIENT_ID，第一步中获取到的客户端ID DRONE_GITHUB_CLIENT_SECRET，第一步中获取到的客户端秘钥 DRONE_RPC_SECRET，第一步中openssl命令创建的共享秘钥 DRONE_SERVER_HOST，Drone服务所在主机域名或者公网IP DRONE_SERVER_PROTO，Drone服务协议，可选”http”和”https” 第四步：启动服务以下是完整的Drone服务运行参数：1234567891011121314docker pull drone/dronedocker run \--volume=/var/lib/drone:/data \--env=DRONE_GITHUB_CLIENT_ID=XXX \--env=DRONE_GITHUB_CLIENT_SECRET=XXX \--env=DRONE_RPC_SECRET=bea26a2221fd8090ea38720fc445eca6 \--env=DRONE_SERVER_HOST=47.104.243.84:9001 \--env=DRONE_SERVER_PROTO=http \--publish=9001:80 \--publish=443:443 \--restart=always \--detach=true \--name=drone \drone/drone 映射端口根据实际需要进行调整，执行完该命令后，Drone服务已经运行起来了，我们可以在浏览器中打开http://47.104.243.84:9001，会出现GitHub授权登陆界面：用GitHub授权成功后，可以进入到服务管理页面。 执行器安装 服务启动成功之后我就迫不及待的去GitHub上建了个用来测试的项目”drone-demo”，不用具体的实现就放一个README.md就可以了，并且按照官网文档在项目根目录增加了一个配置文件.drone.yml：1234567891011121314kind: pipelinetype: execname: defaultplatform: os: linux arch: 386steps:- name: build commands: - pwd - ls -latrigger: branch: - master 回到服务管理页面点击”SYNC”，发现”drone-demo”已经在列表中了，我们在列表中点击对应的”ACTIVATE”链接激活该项目，这样才会触发Drone的构建操作。随便更改drone-demo中的代码然后提交上传，再回到管理页面发现已经触发了构建但问题是一直卡在那里不动了：在网上搜了下，发现基本上都说需要安装drone-agent，而且使用docker-compose一次性安装服务和代理，看起来挺靠谱的，但问题是官网上没有代理的相关描述！不管怎么样，我们还是能看出来是缺少了什么导致的，再回到官网细看才发现还需要安装执行器”Runner”，而执行器分为以下几种： Docker Runner，在相关的docker容器中执行构建步骤，比如我们可以根据需要在不同版本的node容器中执行构建 Kubernetes Runner Exec Runner，这个执行器比较特殊，本次就是使用的这个执行器，其他的几个执行器都是可以通过docker容器形式提供服务，这个是以原生的服务提供，具体安装过程和参数配置这里不细说了，官网上已经很详细了，可以参考官网：在Linux安装Exec执行器 SSH Runner Digital Ocean Runner安装并成功启动exec执行器之后，我们发现原先的构建已经成功了：过程也还算顺利，比当初我在使用Jenkins的时候容易多了。如果安装其他的执行器的话可以使用docker-compose，这样服务和执行器可以一起安装比较方便，这里提供一个docker-compose的配置文件以供参考(只包含Drone服务，根据需要自行添加执行器的相关配置)：12345678910111213141516version: '3'services: drone-server: image: drone/drone ports: - 9001:80 container_name: drone volumes: - /var/lib/drone:/data restart: always environment: - DRONE_GITHUB_CLIENT_ID=XXX - DRONE_GITHUB_CLIENT_SECRET=XXX - DRONE_RPC_SECRET=cf51230bedda724d772507cb7140596f - DRONE_SERVER_HOST=47.104.243.84:9001 - DRONE_SERVER_PROTO=http 后记 我现在还只是停留在试用阶段，Drone的很多功能还有待进一步探索，有兴趣的朋友也可以自己试用一下。 参考资料： https://docs.drone.io/ https://www.cntofu.com/book/139/cases/ci/drone.md]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Drone</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019热门技术合集]]></title>
    <url>%2F2019%2F08%2F25%2Fhot-technologies-of-2019%2F</url>
    <content type="text"><![CDATA[以下收集了2019年软件行业各类热门技术盘点的文章，涵盖了前端、后端、运维、数据库等各项热门技术。 2019十大最佳DevOps工具 值得看看，2019年11个受欢迎的JavaScript动画库！ 决胜未来，2019前端开发十大战略性技术布局 盘点2019年Java开发中7项主流、热门的IT技术！ 2019年必知的10大顶级Python库 2019年CSS的7大趋势与发展 2019年最好的JavaScript图表库 2019数据库趋势报告，最受欢迎的是MySQL]]></content>
      <categories>
        <category>盘点</category>
      </categories>
      <tags>
        <tag>盘点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你必须懂的前端性能优化]]></title>
    <url>%2F2019%2F08%2F20%2Ffront-end-performance-optimization-what-you-must-konw%2F</url>
    <content type="text"><![CDATA[本文作者从页面加载过程、浏览器缓存策略、CDN、图片优化和渲染优化等几个方面详细介绍了前端的相关概念和优化方法。 从输入URL加载起看方向 首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了 TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件 CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了 我们从输入 URL 到显示页面这个过程中，涉及到网络层面的，有三个主要过程： DNS 解析 TCP 连接 HTTP 请求/响应 对于 DNS 解析和 TCP 连接两个步骤，我们前端可以做的努力非常有限。相比之下，HTTP 连接这一层面的优化才是我们网络优化的核心。HTTP 优化有两个大的方向： 减少请求次数 减少单次请求所花费的时间 浏览器缓存策略 浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下： Memory Cache Service Worker Cache HTTP Cache Push Cache MemoryCacheMemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。浏览器秉承的是“节约原则”，我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。 Service Worker Cacheervice Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。 HTTP Cache对一条http get 报文的基本缓存处理过程包括7个步骤： 接收 解析 查询，缓存查看是否有本地副本可用，如果没有，就获取一份副本 新鲜度检测， 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。 创建响应，缓存会用新的首部和已缓存的主体来构建一条响应报文。 发送，缓存通过网络将响应发回给客服端。 日志 强缓存强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。 是否足够新鲜时期：通过 Expires: XXXX XXX XXX GMT （绝对日期时间，http/1.0） 或者 Cache-Control:max-age=XXXX （相对日期时间，http/1.1）在文档标明过期日期。 Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。 关键字理解public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为默认值。 no-store与no-cache，no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。 协商缓存协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。 协商缓存的实现：从 Last-Modified 到 Etag，详细自己百度，这里不再详细展开。 HTTP缓存决策当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。 Push CachePush Cache 是指 HTTP2 在 server push 阶段存在的缓存。 Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。 Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。 CDN了解一番 CDN 的核心点有两个，一个是缓存，一个是回源。 “缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。CDN 往往被用来存放静态资源。所谓“静态资源”，就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。而“动态资源”，顾名思义是需要后端实时动态生成的资源，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。 那“非纯静态资源”呢？它是指需要服务器在页面之外作额外计算的 HTML 页面。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它和业务服务器的操作耦合，我们把它丢到CDN 上显然是不合适的。 另外，CDN的域名必须和主业务服务器的域名不一样，要不，同一个域名下面的Cookie各处跑，浪费了性能流量的开销，CDN域名放在不同的域名下，可以完美地避免了不必要的 Cookie 的出现！ 图片优化 二进制位数与色彩的关系在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。 一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。 计算图片大小对于一张 100 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 1 * 4 / 1024）。但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了： 减少像素点 减少每个像素点能够显示的颜色 图片类型要点PEG/JPG 特点：有损压缩、体积小、加载快、不支持透明,JPG 最大的特点是有损压缩。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。但当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。 PNG 特点：无损压缩、质量高、体积大、支持透明，PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。8 和 24，这里都是二进制数的位数。按照我们前置知识里提到的对应关系，8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是体积太大。 SVG 特点：文本文件、体积小、不失真、兼容性好，SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。 Base64 特点：文本文件、依赖编码、小图标解决方案，Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。 WebP 特点：年轻的全能型选手，WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。但是毕竟年轻，兼容性存在一些问题。 渲染优化 客户端渲染在客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。页面上呈现的内容，你在 html 源文件里里找不到——这正是它的特点。 服务端渲染在服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成HTML字符串，然后把它返回给客户端。页面上呈现的内容，我们在 html 源文件里也能找到。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢，也解决了SEO搜索引擎的问题。 浏览器渲染过程解析浏览器的渲染机制一般分为以下几个步骤： 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 在渲染DOM的时候，浏览器所做的工作实际上是： 获取DOM后分割为多个图层 对每个图层的节点计算样式结果（Recalculate style–样式重计算） 为每个节点生成图形和位置（Layout–回流和重布局） 将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘） 图层作为纹理上传至GPU 复合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组） 基于渲染流程的 CSS 优化建议CSS 选择符是从右到左进行匹配的，比如#myList li {}实际开销相当高。 避免使用通配符，只对需要用到的元素进行选择。 关注可以通过继承实现的属性，避免重复匹配重复定义。 少用标签选择器。如果可以，用类选择器替代。 错误：#dataList li{} 正确：.dataList{} 不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。错误：.dataList#title 正确： #title 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。 CSS 的阻塞CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK。我们将 CSS 放在 head 标签里 和尽快 启用 CDN 实现静态资源加载速度的优化。 JS 的阻塞JS 引擎是独立于渲染引擎存在的。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 DOM渲染优化先了解回流和重绘 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。 重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。 例子剖析123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;DOM操作测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123for(var count=0;count&lt;10000;count++)&#123; document.getElementById('container').innerHTML+='&lt;span&gt;我是一个小测试&lt;/span&gt;' //我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，额外开销&#125; 进化一：12345// 只获取一次containerlet container = document.getElementById('container')for(let count=0;count&lt;10000;count++)&#123; container.innerHTML += '&lt;span&gt;我是一个小测试&lt;/span&gt;'&#125; 进化二：123456789//减少不必要的DOM更改let container = document.getElementById('container')let content = ''for(let count=0;count&lt;10000;count++)&#123; // 先对内容进行操作 content += '&lt;span&gt;我是一个小测试&lt;/span&gt;'&#125; // 内容处理好了,最后再触发DOM的更改container.innerHTML = content 事实上，考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。 在 DOM Fragment 中，DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。 进化三：123456789101112let container = document.getElementById('container')// 创建一个DOM Fragment对象作为容器let content = document.createDocumentFragment()for(let count=0;count&lt;10000;count++)&#123; // span此时可以通过DOM API去创建 let oSpan = document.createElement("span") oSpan.innerHTML = '我是一个小测试' // 像操作真实DOM一样操作DOM Fragment对象 content.appendChild(oSpan)&#125;// 内容处理好了,最后再触发真实DOM的更改container.appendChild(content) 进化四：当涉及到过万调数据进行渲染，而且要求不卡住画面，如何解决？如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; 控件 &lt;/ul&gt; &lt;script&gt; setTimeout(() =&gt; &#123; // 插入十万条数据 const total = 100000 // 一次插入 20 条，如果觉得性能不好就减少 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector('ul') function add() &#123; // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment() for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement('li') li.innerText = Math.floor(Math.random() * total) fragment.appendChild(li) &#125; ul.appendChild(fragment) countOfRender += 1 loop() &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; window.requestAnimationFrame(add) &#125; &#125; loop() &#125;, 0) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 注意：若您想要在下次重绘时产生另一个动画画面，您的回调例程必须调用 requestAnimationFrame()。 Event Loop我们先了解javascript运行机制，对渲染是大有帮助的，可以看我历史文章JavaScript运行机制，Javascript运行机制深入。 事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。 例子分析：12// task是一个用于修改DOM的回调setTimeout(task, 0) 上面代码，现在 task 被推入的 macro 队列。但因为 script 脚本本身是一个 macro 任务，所以本次执行完 script 脚本之后，下一个步骤就要去处理 micro 队列了，再往下就去执行了一次 render,必须等待下一次的loop。1Promise.resolve().then(task) 上面代码，我们结束了对 script 脚本的执行，是不是紧接着就去处理 micro-task 队列了？micro-task 处理完，DOM 修改好了，紧接着就可以走 render 流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。 当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。 上面说了重绘与回流，Event loop，但很多人不知道的是，重绘和回流其实和 Event loop 有关。 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 节流与防抖 当用户进行滚动，触发scroll事件，用户的每一次滚动都将触发我们的监听函数。函数执行是吃性能的，频繁地响应某个事件将造成大量不必要的页面计算。因此，我们需要针对那些有可能被频繁触发的事件作进一步地优化。节流与防抖就很有必要了！ 详细看历史文章防抖动与节流。 本文转自https://segmentfault.com/a/1190000019897234。]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL风格指南]]></title>
    <url>%2F2019%2F08%2F18%2Fsql-style-guide%2F</url>
    <content type="text"><![CDATA[您好!我是Matt Mazur，是一名数据分析师，曾在多家初创公司工作，帮助他们利用数据发展业务。本指南试图记录我对格式化SQL的偏好，以期对其他人有所帮助。如果您或您的团队还没有SQL样式指南，那么这可能是一个很好的起点，您可以根据自己的喜好采用和更新。 另外，我是一个意见偏激者，所以如果您不同意任何一点，给我一个便条，我很乐意去探讨。 如果您对这个主题感兴趣，您可能同样会对我的Matt on Analytics新闻稿件和我写的关于分析学和数据分析的博客感兴趣。 示例 下面是一个非常重要的查询，让您能够了解这个风格指南在实践中是什么样子的：12345678910111213141516171819202122232425262728293031323334353637383940with hubspot_interest as ( select email, timestamp_millis(property_beacon_interest) as expressed_interest_at from hubspot.contact where property_beacon_interest is not null), support_interest as ( select email, created_at as expressed_interest_at from helpscout.conversation inner join helpscout.conversation_tag on conversation.id = conversation_tag.conversation_id where tag = 'beacon-interest'), combined_interest as ( select * from hubspot_interest union all select * from support_interest),final as ( select email, min(expressed_interest_at) as expressed_interest_at from combined_interest group by email)select * from final 准则 使用小写SQL它和大写的SQL一样可读，您不必一直按住SHIFT键。12345678-- Goodselect * from users-- BadSELECT * FROM users-- BadSelect * From users 单行查询与多行查询当你进行以下查询时才可以将所有SQL放到同一行： 所有列（*）或选择1或2列 而且在您的查询中没有额外的复杂性1234567891011-- Goodselect * from users-- Goodselect id from users-- Goodselect id, email from users-- Goodselect count(*) from users 原因很简单，当所有东西都在一条线上时，仍然很容易阅读。但是，一旦您开始添加更多的列或更复杂的列，如果它位于多行上，则更容易阅读：1234567891011-- Goodselect id, email, created_atfrom users-- Goodselect *from userswhere email = 'example@domain.com' 对于具有1列或2列的查询，可以将列放在同一行上。对于3+列，将每个列名称放在自己的行上，包括第一项：12345678910111213141516171819202122232425-- Goodselect id, emailfrom userswhere email like '%@gmail.com'-- Goodselect user_id, count(*) as total_chargesfrom chargesgroup by user_id-- Goodselect id, email, created_atfrom users-- Badselect id, email, created_atfrom users-- Badselect id, emailfrom users 所有内容左对齐123456789-- Goodselect id, emailfrom userswhere email like '%@gmail.com'-- Badselect id, email from users where email like '%@gmail.com' 使用单引号一些SQL方言（如BigQuery）支持使用双引号，但对于大多数方言来说，双引号最终会引用列名。因此，最好使用单引号：123456789-- Goodselect *from userswhere email = 'example@domain.com'-- Badselect *from userswhere email = "example@domain.com" 使用!=而不是只是因为!=读起来像“不等于”，这更接近于我们怎么大声说出来。1234-- Goodselect count(*) as paying_users_countfrom userswhere plan_name != 'free' 逗号应在行尾1234567891011-- Goodselect id, emailfrom users-- Badselect id , emailfrom users 缩进Where条件当只有一个Where条件时，请将其与where保持在同一行：123select emailfrom userswhere id = 1234 如果存在多个条件，则将每个级别缩进到比where更深的一个级别。将逻辑运算符放在前一个条件的末尾：12345select id, emailfrom userswhere created_at &gt;= '2019-03-01' and vertical = 'work' 避免括号内有空格123456789-- Goodselect *from userswhere id in (1, 2)-- Badselect *from userswhere id in ( 1, 2 ) 将in查询值的长列表分隔为多个缩进行123456789-- Goodselect *from userswhere email in ( 'user-1@example.com', 'user-2@example.com', 'user-3@example.com', 'user-4@example.com') 表名应该是蛇形连接复数形式12345678910111213-- Goodselect id, email, timestamp_trunc(created_at, month) as signup_monthfrom users-- Badselect id, email, timestamp_trunc(created_at, month) as SignupMonthfrom users 列名约定 布尔型字段应以is_，has_或does_开头，如：is_customer, has_unsubscribed等。 日期型字段应以_date结尾，如：report_date。 日期时间型字段应以_at结尾，如：created_at, posted_at等。 列顺序约定首先放置主键，接着是外键，然后放置所有其他列。如果表中有任何系统列(created_at, updated_at, is_deleted等)，则放到最后。12345678910111213-- Goodselect id, name, created_atfrom users-- Badselect created_at, name, id,from users 内连接中包含inner最好是显式的，以便连接类型清晰明了：12345678910111213-- Goodselect email, sum(amount) as total_revenuefrom usersinner join charges on users.id = charges.user_id-- Badselect email, sum(amount) as total_revenuefrom usersjoin charges on users.id = charges.user_id 对于联接条件，将首先引用的表放在紧邻on之后这样做可以更容易地确定连接是否会导致结果分散：123456789101112131415161718-- Goodselect ...from usersleft join charges on users.id = charges.user_id-- primary_key = foreign_key --&gt; one-to-many --&gt; fanout select ...from chargesleft join users on charges.user_id = users.id-- foreign_key = primary_key --&gt; many-to-one --&gt; no fanout-- Badselect ...from usersleft join charges on charges.user_id = users.id 单个联接条件应与join在同一行上12345678910111213141516-- Goodselect email, sum(amount) as total_revenuefrom usersinner join charges on users.id = charges.user_idgroup by email-- Badselect email, sum(amount) as total_revenuefrom usersinner join chargeson users.id = charges.user_idgroup by email 当有多个连接条件时，将每个条件放置在各自的缩进行上：123456789-- Goodselect email, sum(amount) as total_revenuefrom usersinner join charges on users.id = charges.user_id and refunded = falsegroup by email 避免表别名12345678910111213-- Goodselect email, sum(amount) as total_revenuefrom usersinner join charges on users.id = charges.user_id-- Badselect email, sum(amount) as total_revenuefrom users uinner join charges c on u.id = c.user_id 唯一的例外是，当您需要多次联接到一个表上并需要区分它们时。 如非必须不要包含表名1234567891011-- Goodselect id, namefrom companies-- Badselect companies.id, companies.namefrom companies 总是重命名聚合和函数包装的参数1234567891011121314151617-- Goodselect count(*) as total_usersfrom users-- Badselect count(*)from users-- Goodselect timestamp_millis(property_beacon_interest) as expressed_interest_atfrom hubspot.contactwhere property_beacon_interest is not null-- Badselect timestamp_millis(property_beacon_interest)from hubspot.contactwhere property_beacon_interest is not null 确保布尔条件是显示的1234567-- Goodselect * from customers where is_cancelled = trueselect * from customers where is_cancelled = false-- Badselect * from customers where is_cancelledselect * from customers where not is_cancelled 使用as定义列别名12345678910111213-- Goodselect id, email, timestamp_trunc(created_at, month) as signup_monthfrom users-- Badselect id, email, timestamp_trunc(created_at, month) signup_monthfrom users 用列名而不是序号做分组1234567891011-- Goodselect user_id, count(*) as total_chargesfrom chargesgroup by user_id-- Badselect user_id, count(*) as total_chargesfrom chargesgroup by 1 使用列别名12345678910111213-- Goodselect timestamp_trunc(com_created_at, year) as signup_year, count(*) as total_companiesfrom companiesgroup by signup_year-- Badselect timestamp_trunc(com_created_at, year) as signup_year, count(*) as total_companiesfrom companiesgroup by timestamp_trunc(com_created_at, year) 分组列应置于最前12345678910111213-- Goodselect timestamp_trunc(com_created_at, year) as signup_year, count(*) as total_companiesfrom companiesgroup by signup_year-- Badselect count(*) as total_companies, timestamp_trunc(com_created_at, year) as signup_yearfrom mysql_helpscout.helpscout_companiesgroup by signup_year 对齐case/when语句每个when都应该在自己的行上（case所在行没有任何内容），并且应该缩进比case行深一层。then可以和when在同一行上或者在下一行，这样做只是为了保持一致。123456789101112131415161718192021222324-- Goodselect case when event_name = 'viewed_homepage' then 'Homepage' when event_name = 'viewed_editor' then 'Editor' end as page_namefrom events-- Good tooselect case when event_name = 'viewed_homepage' then 'Homepage' when event_name = 'viewed_editor' then 'Editor' end as page_namefrom events-- Bad select case when event_name = 'viewed_homepage' then 'Homepage' when event_name = 'viewed_editor' then 'Editor' end as page_namefrom events 使用通CTEs而非子查询避免子查询，CTE（通用表表达式）将使您的查询更容易阅读和解释。使用CTE时，请用新行填充查询。如果使用任何CTE，请始终在末尾使用名为final的CTE，并选择* from final。这样，您就可以快速检查查询中用于调试结果的其他CTE的输出。关闭CTE括号应使用与WITH和CTE名称相同的缩进级别。12345678910111213141516171819202122232425262728293031-- Goodwith ordered_details as ( select user_id, name, row_number() over (partition by user_id order by date_updated desc) as details_rank from billingdaddy.billing_stored_details),final as ( select user_id, name from ordered_details where details_rank = 1)select * from final-- Badselect user_id, namefrom ( select user_id, name, row_number() over (partition by user_id order by date_updated desc) as details_rank from billingdaddy.billing_stored_details) rankedwhere details_rank = 1 使用有意义的CTE名称12345-- Goodwith ordered_details as (-- Badwith d1 as ( 窗口函数您可以将其全部保留在自己的行中，也可以根据其长度将其拆分为多个：12345678910111213141516-- Goodselect user_id, name, row_number() over (partition by user_id order by date_updated desc) as details_rankfrom billingdaddy.billing_stored_details-- Goodselect user_id, name, row_number() over ( partition by user_id order by date_updated desc ) as details_rankfrom billingdaddy.billing_stored_details 感谢 本风格指南灵感来源于： Fishtown Analytics’ dbt Style Guide KickStarter’s SQL Style Guide GitLab’s SQL Style Guide 向Peter Butler、Dan Wyman、Simon Ouderkirk、Alex Cano、Adam Stone、Brian Kim和Claire Carroll提供关于本指南的反馈意见表示感谢。 本文译自https://github.com/mattm/sql-style-guide#guidelines]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个设计模式-前言]]></title>
    <url>%2F2019%2F07%2F22%2Fdaily-design-pattern-preface%2F</url>
    <content type="text"><![CDATA[设计模式(Design Patterns)是前辈们总结出的一套可以反复使用的理论。它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列复杂的问题。1995年GoF四人合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了23种设计模式，这本书成为了设计模式领域的“圣经”。本系列文章在结合自己理解的基础上介绍这些设计模式，同时给出Java和TypeScript两种语言的应用示例。 6大设计原则 《设计模式》一书中首先提出了6大设计原则，接下来的23种设计模式就是基于这些原则总结出的一套方法论。在学习和理解这些原则和设计模式的时候，我们可能会发现设计模式并不是什么高深的技术，在工作的过程中或多或少都已经有所接触或者使用过。 单一职责原则单一职责原则(Single Responsibility Principle,SRP)，原文对它的解释是“There should never be more than one reason for a class to change”即一个对象不应该有多个引起它变化的原因。这句话看起来很简单，但具体应该怎么理解呢？从面向对象角度来说对象由一系列属性和方法组成，引起对象变化也就是通过调用方法改变属性，那么这个原则简单来说就是一个类应当仅包含某一类功能的方法。这样去设计类的确很好，可以提高可读性、降低类的复杂度等。但实际经验告诉我们很少有人会这么做，因为工作过程中会综合考虑工作量以及员工技术水平等因素，往往都会“违背”这一原则。另外，“职责”是一个无法量化的概念，很难依据标准去划分，我们在工作过程中更多的是面向接口编程，应当尽可能保证接口的单一职责和降低类的复杂度。举个例子，我们在遍历集合时经常用到的Iterator接口，从JDK1.2开始仅包含三个方法，直到JDK1.8才增加了一个新的方法：123456789101112131415161718public interface Iterator&lt;E&gt; &#123; // jdk1.2-jdk1.7 boolean hasNext(); E next(); void remove(); // jdk1.8 boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 我们可以看出，一个职责分明、结构清晰的接口可以极大的提升代码的可重用性。 里氏替换原则里氏替换原则(Liskov Substitution Principle,LSP)，这是Liskov于1987年提出关于继承的原则“Inheritance should ensure that any property proved about supertype objects also holds for subtype objects.”即继承必须确保父类所拥有的 在子类中仍然成立，这样父类能出现的地方子类就可以出现。 依赖倒置原则依赖倒置原则(Dependency Inversion Principle,DIP)，它的原始定义是“High level modules should not depend upon low level modules.Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.”归根结底就是实现应该依赖于抽象，再具体点就是在单一职责种提到的“面向接口编程”。 接口隔离原则接口隔离原则(Interface Segregation Principle,ISP)，它的其中一种定义是“The dependency of one class to another one should depend on the smallest possible interface.”即类间的依赖关系应该建立在最小的接口上，这就要求我们定义出的接口需要保证“原子性”，是不是感觉和“单一职责原则”是相同的？其实不然，单一职责强调的是某一类功能的聚合而接口隔离则需要保证接口“干净”没有多余的方法。比如我们简单定义了如下动物接口，并且有两个实现类：12345678910111213141516171819202122232425262728public interface IAnimal &#123; void eat(); void makeTools();&#125;public class People implements IAnimal &#123; @Override public void eat() &#123; System.out.println("I am eating."); &#125; @Override public void makeTools() &#123; System.out.println("I can make tools."); &#125;&#125;public class Ant implements IAnimal &#123; @Override public void eat() &#123; System.out.println("I am eating."); &#125; @Override public void makeTools() &#123; // do noting &#125;&#125; 所有动物都会吃东西，但只有人和部分动物会制造工具，在很多其他动物的实现类中这个方法是多余的，因此这个接口不满足接口隔离原则，但它满足单一职责原则。为了能够满足接口隔离原则，我们可以将makeTools方法提取到一个单独的接口中，其他类根据需要去实现这两个接口：123456public interface IAnimal &#123; void eat();&#125;public interface IToolsMaker &#123; void makeTools();&#125; 迪米特法则迪米特法则(Law of Demeter，LoD)也称为最少知识原则(Least Knowledge Principle，LKP)，意思是类与类之间应减少依赖，它提出的初衷是为了降低类之间的耦合。 开闭原则开闭原则的定义为“Software entities like classes， modules and functions should be open for extension but closed for modifications.”即一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。这个原则要求我们通过扩展来实现变化，而不是修改已有代码。]]></content>
      <categories>
        <category>编程</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TypeScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IDEA中使用FindBugs]]></title>
    <url>%2F2019%2F07%2F20%2Ffindbugs%2F</url>
    <content type="text"><![CDATA[FindBugs用来静态分析和查找Java代码中存在的Bugs，它的运行需要依赖1.7或更高版本的JRE(或JDK)，但是它可以分析从1.0到1.8各个版本的JDK编译出的程序，是一个基于字节码的工具。本文简单介绍了如何在IDEA中使用FindBugs，并对FindBugs的相关概念作出说明。 IDEA中安装使用 安装 在IDEA中ctrl+alt+s打开设置面板，找到”Plugins”选项； 然后选择”Browse repositories…”在搜索框中输入”findbugs”查找插件，结果列表中选择”FindBugs-IDEA”并安装； 安装完成后重启IDEA方可生效。 使用 重启后，可以在下列截图中看到最下方工具栏中多出了”FindBugs-IDEA”一项，同时右键选项中也多出了”FindBugs”选项。截图分成了4列，其中第一列中是FindBugs工具栏，可以选择分析范围和分析结果分组；第二列是分析结果列，在该列中选择一个分析出来的Bug后，第三列和第四列会相应展示这个Bug出现的位置以及Bug的详细说明。 说明分析范围 当前文件 当前类(对于含内部类的文件，可以选择只分析光标所在类) 当前包 当前模块 当前工程 指定范围 所有修改的文件(需要结合VCS) changelist中的类(需要结合VCS) 结果分组 根据Bug分类分组，这也是默认的分组 根据类分组 根据包分组 根据Bug严重级别分组，工作中推荐使用的，可以相应优先处理严重级别较高的Bug。 严重级别 Of Concren - 建议, 如果遵循能更好的完善代码 Troubling - 不好的, 可能会引发不良后果 Scary - 严重问题, 在某种情况下一定会出现问题 Scariest - 非常严重, 已经影响到当前程序功能 Bug类型及示例 FindBugs定义了很多详细的Bug类型，这里针对每个大类仅列出一些比较常见的类型，完整列表请参考官网FindBugs Bug Descriptions。 Bad practice - 不好的习惯(仔细看下来有些Bug会导致程序错误，因此也需要谨慎对待) 比较字符串时使用”==”或”!=” 不可变类成员变量没有声明为”final” Correctness - 正确性 方法参数顺序颠倒，比如Preconditions.checkNotNull(“message”, message) 字符串格式化时缺少参数，比如formatter.format(“%s %s”, “a”) Experimental - 实验性的 没有使用try-finally进行关闭IO流 Internationalization - 国际化(在支持多语言时需要关注) 字符和字节数组转换时没有指定字符集 Malicious code vulnerability - 恶意代码漏洞 成员变量在一些情况下应声明为”final”但没有 Multithreaded correctness - 多线程正确性 多线程情况下可能存在双重检查锁的情况(单例模式下需注意) 使用静态的日期格式化相关对象，如：SimpleDateFormat Performance - 性能 在循环体重使用”+”号连接字符串，我们知道平时字符串变量使用”+”连接时编译器会进行优化为一个StringBuilder对象进行字符串拼接，但在循环体中会创建多个StringBuilder对象，大大增加了时间和空间的开销 对于没有引用父对象的子类没有定义为”static”，很好理解，这种做法会无意义的增加父对象的大小，并且父对象会持有无效的引用 定义了从未被使用的成员变量 Security - 安全 硬编码或者使用空的数据库密码 动态SQL语句没有使用”prepared statement” Dodgy code - 可疑代码 冗余的空值检查 Swich语句块缺少Default语句 在可能导致空指针异常的地方没有进行非空检查 后记 在IDEA中使用FindBugs是如此简单，但起到的作用真的太大了。在平时的工作中，由于各种因素程序中难免会存在不规范甚至错误的地方，有些错误只是一直没有暴露出来而已，等到真正暴露的时候已经为时已晚。所以我们应该尽可能的去避免这种情况的发生，FindBugs就是一个很好的选择。当然，我们不能完全依赖于工具，还应当做好代码审查以及测试等工作，工具只是一种补充手段。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工具</tag>
        <tag>FindBugs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK版本历史]]></title>
    <url>%2F2019%2F06%2F24%2Fjdk-versions%2F</url>
    <content type="text"><![CDATA[记录了JDK的发展历史以及各版本的主要特性，将持续进行收集和更新。 JDK1.0 简介1996年1月23日发布，这是Java语言的第一个正式版本。 新特性 Java虚拟机 Applet AWT JDK1.1 简介1997年2月19日发布。 新特性 JAR文件格式 JDBC JavaBeans RMI 内部类 反射 JDK1.2 简介1998年12月4日发布，工程代号Playground(竞技场)，这是一个里程碑式的版本，它将Java技术体系分为3个方向，就是我们熟知的面向桌面应用开发的J2SE(Java 2 Platform, Standard Edition)、面向企业级开发的J2EE(Java 2 Platform, Enterprise Edition)和面向移动端开发的J2ME(Java 2 Platform, Micro Edition)。 新特性 EJB Java Plug-in Java IDL Swing 内置了JIT(Just In Time)编译器 增加strictfp关键字 Collections集合类 JDK1.3 简介2000年5月8日发布，工程代号Kestrel(美洲红隼)，从这个版本开始Sun大约每隔两年发布一个以动物命名JDK的主版本，期间发布的修正版本以昆虫命名。如修正版本1.3.1工程代号为Ladybird(瓢虫)。 新特性 JNDI 数学运算和Timer API 改进JAVA 2D，新增大量API 新增JavaSound类库 JDK1.4 简介2002年2月13日发布，工程代号Merlin(灰背隼)。与此同时，微软的.NET Framework也在此时发布，它在技术实现和目标客户上都与Java有很多相近之处。 新特性 NIO 正则表达式 异常链 日志类 XML解析器和XLST转换器 JDK5 简介2004年9月30日发布，工程代号Tiger(老虎)。从1.5.0开始调整命名(也可以说是出现命名分支)，产品概念上是“5.0”，对于大部分开发者来说习惯了“1.”的叫法，所以“1.5.0”(或1.5)依然被延续下来(参见：Version 1.5.0 or 5.0?)，这个版本在语法上作了很大的改进。 新特性 改进Java的内存模型(Java Memory Modal，JMM) 提供java.util.concurrent并发包 自动拆装箱 泛型 动态注解 枚举 可变长参数 遍历循环(foreach循环) JDK6 简介2006年12月11日发布，工程代号Mustang(野马)。结束了J2EE、J2SE和J2ME的命名方式，启用Java SE6、Java EE 6和Java ME 6的命名方式。 新特性 动态语言支持(通过内置Mozillaa JavaScript Rhino引擎实现) 提供编译API 微型HTTP服务器API 改进了锁与同步、垃圾收集和类加载等 JDK7 简介2009年2月19日发布，工程代号Dolphin(海豚)。同年4月20日，Oracle正式收购Sun公司, JDK开始开源(OpenJDK)，这注定是一个多事之秋，最开始规划的很多内容包括Lambda表达式等都延迟到了JDK1.8才实现；这也是Java的一次机遇，Oracle收购Sun公司后，取得了三大虚拟机中的其中两个：JRockit(BEA公司)和HotSpot(Sun公司，另外一个为IBM的J9)，宣布把这两个优秀的虚拟机互相取长补短，因此在随后的一个版本中虚拟机技术将会产生巨大的变化。 新特性 提供新的G1收集器 升级类加载架构 Try-With-Resources JDK8 简介2014年3月18日发布，时隔五年，这是Oracle收购Sun后发布的第一个版本，也是比较重要的一个版本。完整新特性参考：What’s New in JDK 8 新特性 Lambda表达式 Stream API Date Time API 标准Base64编码/解码 接口默认方法 移除持久代(PermGen) 新的Nashorn javascript引擎 JDK9 简介 2017年9月22日发布，不久之前Oracle宣布将Java的发布周期改为每六个月一次，也就是之后每年的3月份和9月份都会发布一个新的版本。完整特性参考：What’s New in Oracle JDK 9 新特性 模块化(Modularity) REPL(Read-eval-print-loop，交互式解析器)工具JShell 轻量级Json Api 提供了消息发布订阅框架 私有接口方法 JDK10 简介2018年3月20日发布，完整特性参见：Java Language Updates 新特性 局部变量类型推断 1var x = new ArrayList&lt;String&gt;(); 垃圾收集器接口 向G1引入并行Full GC 在备用内存设备上分配堆内存。允许 HotSpot 虚拟机在备用内存设备上分配 Java 对象堆 基于Java的JIT编译器（试验版本） JDK11 简介2018年9月26日发布，这是自1.8版本以后又一个LTS(Long-Term-Support，长期支持，每三年发布一次)版本，完整特性参考What’s New in JDK 11。 新特性 ZGC(Z Garbage Collector，实验性)，可扩展低延迟 Epsilon无操作垃圾回收器（Epsilon 垃圾回收器，又被称为”No-Op”回收器） HTTP Client 移除了很多包和模块，比如JavaFX、JMC等 JDK12 简介2019年3月20日发布，完整特性参考What’s New in JDK 12 新特性 JVM常量API Switch表达式]]></content>
      <categories>
        <category>编程</category>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CSS代码片段]]></title>
    <url>%2F2019%2F06%2F11%2Fcss-snippet%2F</url>
    <content type="text"><![CDATA[主要记录了一些常用的样式代码片段和实现效果，将持续进行收集和更新。 外层盒阴影 盒阴影在网页中比较常用，能够很好的组织和区分各个模块。以下利用CSS3的box-shadown实现，具体参数含义参考box-shadown参数说明 代码 12345.outer-shadow &#123; -webkit-box-shadow: 2px 2px 10px 2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 2px 2px 10px 2px rgba(0, 0, 0, 0.52); box-shadow: 2px 2px 10px 2px rgba(0, 0, 0, 0.52);&#125; 效果 透明 在一些地方经常需要用到透明字体，比如输入框的占位符等，下面给出了适应于不同浏览器的实现。 代码 123456.transparent &#123; filter: alpha(opacity=50); -moz-opacity: 0.5; -khtml-opacity: 0.5; opacity: 0.5;&#125; 效果 列表纸质效果 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ul.box &#123; position: relative; z-index: 1; /* prevent shadows falling behind containers with backgrounds */ overflow: hidden; list-style: none; margin: 0; padding: 0;&#125;ul.box li &#123; position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;&#125;ul.box li:before,ul.box li:after &#123; content: ''; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg);&#125;ul.box li:after &#123; left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg);&#125; 效果 缝合效果 代码 1234567891011121314151617181920212223242526272829303132333435363738p &#123; position: relative; z-index: 1; padding: 10px; margin: 10px; font-size: 21px; line-height: 1.3em; color: #fff; background: lightblue; -webkit-box-shadow: 0 0 0 4px lightblue, 2px 1px 4px 4px rgba(10, 10, 0, .5); -moz-box-shadow: 0 0 0 4px lightblue, 2px 1px 4px 4px rgba(10, 10, 0, .5); box-shadow: 0 0 0 4px lightblue, 2px 1px 6px 4px rgba(10, 10, 0, .5); -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;&#125;p:before &#123; content: ""; position: absolute; z-index: -1; top: 3px; bottom: 3px; left: 3px; right: 3px; border: 2px dashed #fff;&#125;p a &#123; color: #fff; text-decoration: none;&#125;p a:hover,p a:focus,p a:active &#123; text-decoration: underline;&#125; 效果 垂直居中 代码 12345.container &#123; min-height: 10em; display: table-cell; vertical-align: middle;&#125; 效果 文本溢出省略 代码 1234567.text-ellipsis &#123; border: 1px solid lightgray; width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 效果]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用网站集合]]></title>
    <url>%2F2019%2F06%2F11%2Ftools%2F</url>
    <content type="text"><![CDATA[主要记录了一些工具或者参考资料类等常常需要用到的网站，将持续进行收集和更新。 工具箱 oschina在线工具 一个工具箱 toolfk-程序员在线工具大全 编程 在线接口测试 在线正则表达式测试 模拟数据服务 Web开发测试工具集合 30秒掌握JS代码片段 两行代码统计PV 许可证 开源许可证选择 国内第一个开源协议-木兰宽松许可证 排版/转换 复制内容转为Markdown格式 在线格式化 数学公式截图转为latex排版 Unix时间戳 在线二维码生成 Nginx配置文件生成 cron表达式生成器 文字转图片 在线国际化 函数图形，可生成动态演示 AsciiMath，网页工具，可以将 ASCII 字符的公式转为数学字体显示 表格转换为各种格式，支持markdown/json/csv/json等格式 编辑器 在线Markdown编辑器 jsbin-在线编写调试JS jsfiddle-JS在线调试 codepen-前端在线开发，可嵌入到页面，含很多特效源码 codesandbox-前端代码沙盒，可以嵌入到页面 vscode网页版 在线拾色器 在线比较文本差异，支持普通文本、json和xml格式 加密/解密 在线加密/解密 Base64编码 多媒体 在线录屏工具 在线PS 开源视频编辑器 PDF相关功能，包括格式转换等很多功能 去除图片背景 在线画ASCII码框图 趣味 需要我帮你百度吗 演示汉字笔画顺序的JS库 各种绳结打法并配有视频教学 各种表情包收集项目 独角兽公司榜单，实时更新估值超过10亿美元的创业公司 前端技术实现的仿黑客帝国文字雨 参照/文档 HTTP状态码详解 RFC文档 谷歌JS编码规范 Node的API文档 JEP，Java增强提案(JDK Enhancement Proposal) JSDoc中文文档 IntelliJ Platform SDK GitHub官方教程 CSS预处理器stylus Swig文档 JSR，Java规范请求(Java Specification Requests) Java SE官方文档 MDN-Web开发技术文档 教程 菜鸟教程 极客学院 计算机组织导论 黑客工具教程 第九频道，包括很多课程视频 运维学校 免费编程笔记下载 Linux系统免费教程 处理器设计 CPU是怎样工作的 素材 17素材 阿里巴巴矢量图标库 ionicons-图标库 阮一峰整理免费资源合集 SVG格式Logo 千库网 无版权插图库 PPT模板 CSS特效 pixabay免费图片 33个免费图标网站 常用的SVG图标库 搜索引擎 多吉 中文搜索聚合网站 资源 Kindle电子书分享网 开源项目/资源收集分类 Chrome插件整理 静态网站生成器 海盗湾中文网BT资源 jsdelivr，npm/git的JS资源开源CDN 快速查看搜素Linux内核源码 植物画册 网络 wireshark-网络数据包分析 在线测速 anydesk-windows远程桌面连接工具，类似teamview，兼容性更好 学术 龙猫学术导航 在线古籍 鲁迅资料在线检索系统 未完待续…]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
